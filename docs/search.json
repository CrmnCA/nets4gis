[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to Network Analysis for GIS",
    "section": "",
    "text": "Welcome\nThis website hosts the materials for the workshop “An Introduction to Network Analysis for GIS”. The training workshop was designed by Dr Carmen Cabrera-Arnau, Prof Francisco Rowe, Dr Rafael Prieto Curiel, Andrew Renninger and Valentina Marin Maureira.\nThe website is free to use and is licensed under the Attribution-NonCommercial-NoDerivatives 4.0 International.\n\n\nContact\n\nDr Carmen Cabrera-Arnau, Lecturer in Geographic Data Science\nc.cabrera-arnau [at] liverpool.ac.uk\nDepartment of Geography & Planning, University of Liverpool, UK"
  },
  {
    "objectID": "come-prepared.html#workshop-structure",
    "href": "come-prepared.html#workshop-structure",
    "title": "1  Come prepared",
    "section": "1.1 Workshop structure",
    "text": "1.1 Workshop structure\n\n\n\nTime\nActivity\n\n\n\n\n15 min\nWelcome, introduction to workshop activities\n\n\n20 min\nDownloading the workshop materials from Github\n\n\n35 min\nImporting libraries, network theory basics\n\n\n10 min\nComfort break\n\n\n45 min\nThe African road network\n\n\n45 min\nExperiments and percolation\n\n\n10 min\nWrap-up"
  },
  {
    "objectID": "come-prepared.html#before-the-workshop",
    "href": "come-prepared.html#before-the-workshop",
    "title": "1  Come prepared",
    "section": "1.2 Before the workshop",
    "text": "1.2 Before the workshop\n\n\n\n\n\n\nImportant\n\n\n\nPlease make sure you download and install the most recent version of R, RStudio and Quarto on the computer that you will be using during the workshop, and install the indicated R packages – see detailed instructions below.\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll three software packages are open and free to use.\n\n\nR\nYou can download R here. Make sure you select the appropriate version for your Operating System: Windows, MacOS (Apple silicon M1/M2 or older intel Macs). For example, if you use a macOS laptop with an M1 processor, click on ‘Download R for macOS’ and then, click the link to download the installer file (.pkg extension for macOS) under the header ‘For Apple silicon (M1/M2) Macs’. You can then open the installer and follow the instructions that you will be prompted with. For Windows users, click on ‘install R for the first time’ and follow the prompts.\nRStudio\nYou will also need to download RStudio Desktop (or simply RStudio), which is an integrated development environment to help you write code in R more easily. To download RStudio, follow this link and scroll down to the section titled ‘All Installers and Tarballs’. Download the appropriate installer file according to your Operating System. Then, open the installer and follow the installation instructions that you will be prompted with.\nQuarto\nDownload Quarto from this website. Quarto is a publishing system that will allow you to open and work on the computational notebooks for the workshop. On ‘Step 1’ on the website, download the version of Quarto that matches your Operating System. Open the installer file, run it and follow the prompts.\nR packages\nOnce you have installed R, you will need to install some R extensions, known as packages, that will be useful for the applications explored in this workshop. In this case, you only need to install one package:\n\nigraph\n\nTo install any package, open RStudio. On the console window (normally at the bottom left), write the following command: install.packages(\"name of package\"). Make sure you replace “name of package” by the actual name of the package that you want to install e.g. install.packages(\"tidyverse\"). Then, press enter and repeat this process until you have installed all the packages in the list.\nIf there are several packages you need to install (suppose you need to install tidyverse, ggthemes, igraph and dyplr), you can also install them all at once by copying and running the code below:\n\nlist.of.packages.cran <- c(\n   \"tidyverse\",\n   \"ggthemes\",\n   \"igraph\",\n   \"dyplr\"\n)\n\nnew.packages.cran <- list.of.packages.cran[!(list.of.packages.cran %in% installed.packages()[,\"Package\"])]\nif(length(new.packages.cran)) install.packages(new.packages.cran)\n\nfor(i in 1:length(list.of.packages.cran)) {\n  library(list.of.packages.cran[i], character.only = T)\n}\n\nOnce your packages are install, you will need to load them in order to be able to use it in your code. This can be done by copying and running the code below:\n\ndeps <- list(\n   \"tidyverse\",\n   \"ggthemes\",\n   \"igraph\",\n   \"dyplr\"\n)\n\nfor(lib in deps){library(lib, character.only = TRUE)}\n\nBut as we mentioned, we only need igraph here, so you can install it simply using install.packages(\"igraph\") and once it is installed, you can load it simply running library(igraph).\n\n\n\n\n\n\nImportant\n\n\n\nFurther instructions on how to download the workshop material from Github will be given during the workshop."
  },
  {
    "objectID": "introduction-networks.html#dependencies",
    "href": "introduction-networks.html#dependencies",
    "title": "2  Introduction to the basics of network analysis",
    "section": "2.1 Dependencies",
    "text": "2.1 Dependencies\nWe first install all the libraries required for this session.\n\n# working with spatial data\nlibrary(sf)\n# data manipulation and visualisation\nlibrary(tidyverse)\n# network manipulation and analysis\nlibrary(igraph)"
  },
  {
    "objectID": "introduction-networks.html#creating-networks",
    "href": "introduction-networks.html#creating-networks",
    "title": "2  Introduction to the basics of network analysis",
    "section": "2.2 Creating networks",
    "text": "2.2 Creating networks\nWe first consider the components of a network object. Generally, a network (or a graph) consists of nodes (a.k.a. vertices) and edges (a.k.a. links). Edges link nodes to form a network. Networks are used as a tool to conceptualise many real-life situations, such as the friendships among members of a school year group, airline flights between cities or hyperlinks between websites.\n\n2.2.1 Starting from the basics\nTo understand the basic concepts and components of a network, we create a small example network in R using the igraph package. We create an undirected network of 5 nodes and 6 edges.\n\n# create a graph object\nnetwork <- graph( \n  n = 5, # add number of nodes\n  edges = c(1,2, \n            2,3, \n            2,5, \n            3,1, \n            3,4, \n            4,5, \n            5,1), # add edges\n  directed = FALSE )\n\n# plot\nplot(network, \n     layout = layout.circle(network), # set layout\n     vertex.label = 1:5)\n\n\n\n\nIf the connections between the nodes of a network are non-reciprocal, the network is called directed.\n\n# create a graph object\nnetwork <- graph( \n  n = 5, # add number of nodes\n  edges = c(1,2, \n            2,3, \n            2,5, \n            3,1, \n            3,4, \n            4,5, \n            5,1), # add edges\n  directed = TRUE )\n\n# plot\nplot(network, \n     layout = layout.circle(network), # set layout\n     vertex.label = 1:5)\n\n\n\n\nThe network can also be defined as a list containing pairs of nodes with labels. In that case we do not need tospecify the number of nodes. We only specify the isolated nodes to be included.\n\n\n\n\n\n\nNote\n\n\n\nWe will describe the various arguments within plot which can be used to style your data visualisation\n\n\n\n# create a graph object\nnetwork_isolated <- graph( \n  c(\"City 1\",\"City 2\", \n    \"City 2\",\"City 3\", \n    \"City 2\",\"City 5\", \n    \"City 3\",\"City 1\", \n    \"City 3\",\"City 4\", \n    \"City 4\",\"City 5\", \n    \"City 5\",\"City 1\"),\n  isolates=c(\"City 6\") # isolated node\n  )\n\n# plot\nplot(network_isolated, \n      layout = layout.circle(network_isolated),\n     vertex.frame.color=\"red\",  \n     vertex.label.color=\"black\",\n     vertex.label.cex=0.9, \n     vertex.label.dist=2.3, \n     edge.curved=0.3, \n     edge.arrow.size=.5, \n     edge.color = \"blue\", \n     vertex.color=\"yellow\", \n     vertex.size=15) \n\n\n\n\n\n\n2.2.2 Adding attributes\nWe can add attributes to individual components of the network. To add attributes to nodes, we need to access them:\n\nV(network_isolated)\n\n+ 6/6 vertices, named, from 56254f0:\n[1] City 1 City 2 City 3 City 5 City 4 City 6\n\n\nNode attribute names are automatically generated from the node labels we assigned.\n\nV(network_isolated)$name\n\n[1] \"City 1\" \"City 2\" \"City 3\" \"City 5\" \"City 4\" \"City 6\"\n\n\nAdditional node attributes can be added, such as population size:\n\nV(network_isolated)$population <- c(92000, 549000, 1786000, 74000, 8000, 21000)\n\nWe can access the edges:\n\nE(network_isolated)\n\n+ 7/7 edges from 56254f0 (vertex names):\n[1] City 1->City 2 City 2->City 3 City 2->City 5 City 3->City 1 City 3->City 4\n[6] City 4->City 5 City 5->City 1\n\n\nWe can add edge attributes, such as the number of people moving from an origin to a destination city. We call this attribute edge weight. The size of the connection between two places often represent their importance or “weight” in the network.\n\nE(network_isolated)$weight <- c(2000, 5000, 1000, 1000, 4000, 3500, 7000)\n\nWe can examine the adjacency matrix of the network. The adjacency represents the presence of edges between different pairs of nodes. In our example, each row corresponds to an origin city and each column to a destination:\n\nnetwork_isolated[]\n\n6 x 6 sparse Matrix of class \"dgCMatrix\"\n       City 1 City 2 City 3 City 5 City 4 City 6\nCity 1      .   2000      .      .      .      .\nCity 2      .      .   5000   1000      .      .\nCity 3   1000      .      .      .   4000      .\nCity 5   7000      .      .      .      .      .\nCity 4      .      .      .   3500      .      .\nCity 6      .      .      .      .      .      .\n\n\nWe can also look at the existing node and edge attributes.\n\nvertex_attr(network_isolated)\n\n$name\n[1] \"City 1\" \"City 2\" \"City 3\" \"City 5\" \"City 4\" \"City 6\"\n\n$population\n[1]   92000  549000 1786000   74000    8000   21000\n\n\nWe can also add a network attribute:\n\nnetwork_isolated$title <- \"Network of human mobility between cities\"\n\n\n\n2.2.3 Basic visualisation\nYou have already seen how we can visualise networks using the base R function plot. We will now elaborate on how individual components of the network can be visually adjusted using specific parameters in the plot function. More sophisticated data visualisations can be produced integrating geographic information, see Chapter 5 in Rowe, Cabrera-Arnau, and Piestrostefani (2023).\n\nplot(network_isolated,\n     layout = layout.circle(network_isolated),\n     # adjust nodes\n     vertex.frame.color = \"gray90\",    # line colour\n     vertex.label.color = \"black\",    # label colour \n     vertex.label.cex = 1,            # label font size\n     vertex.label.dist = 3,           # label distance\n     vertex.color = \"yellow\",         # colour \n     vertex.size=10,                  # size\n     # adjust edges\n     edge.curved=0.3,     # curvature\n     edge.arrow.size=0.5,  # size\n     edge.arrow.width=.5,\n     edge.width=E(network_isolated)$weight,\n     edge.color = \"gray\") # colour"
  },
  {
    "objectID": "introduction-networks.html#network-metrics",
    "href": "introduction-networks.html#network-metrics",
    "title": "2  Introduction to the basics of network analysis",
    "section": "2.3 Network metrics",
    "text": "2.3 Network metrics\nNext we will provide a brief description of commonly used metrics to analyse the basic structure of networks.\n\n2.3.1 Density\nThe density of a network refers to the proportion of existing edges over all possible edges. In a network with \\(n\\) nodes, the total number of possible edges is \\(x \\times (n-1)\\). A density equal to \\(1\\) corresponds to a situation where \\(x \\times (n-1)\\) edges are present. A network with no edges at all would have density equal to 0. We can obtain the density of a network by running the following code:\n\nedge_density(network_isolated, \n             loops=FALSE)\n\n[1] 0.2333333\n\n\n\n\n2.3.2 Reciprocity\nThe reciprocity in a directed network is the proportion of reciprocated connections between nodes (i.e. number of pairs of nodes with edges in both directions) from all the existing edges.\n\nreciprocity(network_isolated)\n\n[1] 0\n\n\n\n\n2.3.3 Degree\nThe degree of a node is the number of edges connecting a given node i.e. starting or ending at a given node. The in-degree of a node in a directed network is the number of edges ending in a given node. The out-degree is the number of edges starting from a given node. The degree() function allows computing the degree of one or more nodes, and specifying the measures of interest i.e. the total degree, in-degree or out-degree.\n\n# compute in-degree\nnet_degree <- degree(network_isolated, \n                     v=V(network_isolated), \n                     mode=\"in\")\n\n# display histogram of in-degree\nhist(net_degree, \n     breaks = 30, \n     main = \"Node in-degree\")\n\n\n\n\n\n\n2.3.4 Distance\nA path in a network between node \\(A\\) and node \\(B\\) is a sequence of edges joining distinct nodes, starting at node \\(A\\) and ending at node \\(B\\). In a directed path edges are all directed at the same direction.\nThe path length between nodes \\(A\\) and \\(B\\) is generally defined as the number of edges forming a path. The shortest path is the minimum count of edges present to travel from \\(A\\) to \\(B\\).\nThe path length can be defined in alternative ways. For example, the path length can be defined as the sum of the weights of the edges forming a path if the edges are weighted.\nWe can use the function shortest_paths() to find the shortest path between a given pair of nodes:\n\nshortest_paths(network_isolated, \n               from = V(network_isolated)$name == \"City 1\",\n               to = V(network_isolated)$name == \"City 5\",\n               weights=NA, # if weights = NULL and a weight edge attribute is present, this is used.\n               output = \"both\") # outputs are produced for both path nodes and edges\n\n$vpath\n$vpath[[1]]\n+ 3/6 vertices, named, from 56254f0:\n[1] City 1 City 2 City 5\n\n\n$epath\n$epath[[1]]\n+ 2/7 edges from 56254f0 (vertex names):\n[1] City 1->City 2 City 2->City 5\n\n\n$predecessors\nNULL\n\n$inbound_edges\nNULL\n\n\nOf all shortest paths in a network, the longest path length is the network diameter.\n\ndiameter(network_isolated, \n         directed=TRUE, \n         weights=NA)\n\n[1] 4\n\n\nThe mean distance is the average length of all shortest paths in the network. The mean distance will always be smaller or equal than the diameter.\n\nmean_distance(network_isolated, \n              directed=TRUE, \n              weights=NA)\n\n[1] 2\n\n\n\n\n2.3.5 Centrality\nCentrality metrics assign scores to nodes (and sometimes also edges) according to their position within a network. These metrics can be used to identify the most influential nodes.\nWe can measure the degree of a node, or the weighted degree of a node. This is known as the strength of a node. It is the sum of edge weights linked to adjacent nodes, or also known as in-flow or out-flow associated with each node.\n\n# compute strength of network nodes\nnet_strength <- strength(network_isolated, # network object\n                         vids = V(network_isolated), #  vertices\n                         mode = c(\"in\"), # “in” for in-degree\n                         loops = FALSE, # whether to loop the edge count\n                         weights = NULL # if weights = NULL and a weight edge attribute is present, this is used.\n)\n  \n# histogram \nhist(net_strength, \n     breaks = 50, \n     main=\"Histogram of node strength\")\n\n\n\n\nTwo important centrality metrics are (1) closeness centrality, and (2) betweenness centrality. Closeness centrality is a measure of the shortest path length between a node and all the other nodes. For a given node, it is computed as the inverse of the average shortest paths between that node and every other node in the network. A node with closeness centrality close to 1 indicates that on average the node is very close to the other nodes in the network. A closeness centrality of 0 represents an isolated node.\n\nclose_centr <- closeness(network_isolated, \n                         mode=\"in\", \n                         weights=NA) # using unweighted edges\n\nhist(close_centr, \n     breaks = 50, \n     main = \"Histogram of closeness centrality\")\n\n\n\n\nBetweenness centrality is a measure of the number of shortest paths going through a node. Nodes with high values of betweenness centrality indicates that they play a very important role in the overall connectivity of the network. Betweenness can also be computed for edges.\n\nbetween_centr <- betweenness(network_isolated, \n                             v = V(network_isolated), \n                             directed = TRUE, \n                             weights = NA)\n\nhist(between_centr, \n     breaks = 50, \n     main = \"Histogram of betweenness centrality\")\n\n\n\n\n\n\n2.3.6 Hubs and authorities\nWe call hubs or authorities nodes with a higher-than-average degree. Normally, the name hub is used to nodes with high out-degree. Authority is used to nodes with high in-degree. Jon Kleinberg developed an algorithm to detect hubs and authorities.\n\nnet_hub <- hub_score(network_isolated, \n                weights=NULL)$vector #  use the weighted edges\n\nhist(net_hub, \n     breaks = 50, \n     main = \"Histogram of hub score\")\n\n\n\n\nWe can also explore the authority score for each node:\n\nnet_aut <- authority_score(network_isolated, \n                           weights=NULL)$vector\n\nhist(net_aut, \n     breaks = 50, \n     main = \"Histogram of authority score\")\n\n\n\n\n\n\n\n\nRowe, Francisco, Carmen Cabrera-Arnau, and Elisabetta Piestrostefani. 2023. Population Science. population-science.net."
  },
  {
    "objectID": "african-network.html#dependencies",
    "href": "african-network.html#dependencies",
    "title": "3  The African road network",
    "section": "3.1 Dependencies",
    "text": "3.1 Dependencies\n\n# An R package for network manipulation and analysis\nlibrary(igraph)"
  },
  {
    "objectID": "african-network.html#data",
    "href": "african-network.html#data",
    "title": "3  The African road network",
    "section": "3.2 Data",
    "text": "3.2 Data\nHere, we work with a network of African roads constructed by considering all continental cities with more than 100,000 inhabitants as the nodes, obtained from (Moriconi-Ebrard, Harre, and Heinrigs 2016). The edges of the network were created based on the road infrastructure from OpenStreetMap (“Openstreetmap.org”), using all primary roads, highways and trunk roads. Each edge was constructed by measuring the physical distance of consecutive points that describe the intricate patterns of the roads. Thus, a reasonably good estimate of its road length is available for each edge. Additional nodes besides cities are needed to fully describe the road infrastructure, such as some road intersections. These nodes are labelled as “transport nodes” and help define possible routes between cities. Some transport nodes correspond to towns with less than 100,000 inhabitants, so they are labelled as attached to nearby cities. The urban network enables us to consider the existing roads in the continent and measure the travelling distance rather than the physical distance between cities. The constructed network is formed by 7,361 nodes (2,162 cities and 5,199 transport nodes) and 9,159 edges. For more details on how the network was built, see (Prieto-Curiel et al. 2022).\nThe network is connected, meaning that it is possible to find a sequence of nodes and existing roads linking any pair of cities, and therefore, it is also possible to find the shortest road distance between any two cities and define it as the network distance. The network consists of 361,000 km of road infrastructure and connects 461 million people living in African cities, representing roughly 39% of the continent’s population (Prieto Curiel, Cabrera-Arnau, and Bishop 2022)."
  },
  {
    "objectID": "african-network.html#creating-a-network-from-data-frame",
    "href": "african-network.html#creating-a-network-from-data-frame",
    "title": "3  The African road network",
    "section": "3.3 Creating a network from data frame",
    "text": "3.3 Creating a network from data frame\nThe data that specifies the nodes and edges of the African road network is stored in two csv files, one for nodes and one for edges. This data can be loaded in two dataframes:\n\n# Read the CSV file containing network nodes data from a URL\ndf_nodes <- read.csv(\"https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkNodes.csv\")\n\n# Read the CSV file containing network edges data from a URL\ndf_edges <- read.csv(\"https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkEdges.csv\")\n\nWe can then create an undirected graph as an igraph object from the data frames corresponding to the nodes and edges:\n\n# Create a graph 'g_africa' from data frames 'df_edges' and 'df_nodes'\n# The graph is undirected (directed = FALSE)\ng_africa <- graph_from_data_frame(d = df_edges,\n                                       vertices = df_nodes,\n                                       directed = FALSE)\n\nWe can have a look at the names of the vertex attributes, which are automatically taken from the columns in the df_nodes data frame:\n\n# Retrieve the attribute names associated with vertices in the 'g_africa' graph\nvertex_attr_names(g_africa)\n\n[1] \"name\"       \"agglosName\" \"x\"          \"y\"          \"Pop2015\"   \n[6] \"ISO3\"       \"Region\"     \"Between\"    \"degree\"    \n\n\nwhere “name” is the ID of each node in the network, “agglosName” is the name of the city represented by the node, it is set to “road” if the node is a transport node. “x” and “y” represent the coordinates of each node, “Pop2015” is the population of the city nodes, “ISO3” is the code for the country that each node is situated in, “Region” represents the region within the African continent that each node is situated in, and “Between” and “degree” represent the betweenness centrality and the degree of each node in the network, which we will also compute below.\nIn particular, we can look at the first few values of the attribute “name”:\n\n# Retrieve the first few vertex names from the 'g_africa' graph\nhead(V(g_africa)$name)\n\n[1] \"2320\" \"5199\" \"7098\" \"4220\" \"4858\" \"5331\"\n\n\nWe can also obtain the names of the edge attributes, which are taken from the columns in the df_edges data frame:\n\n# Retrieve the attribute names associated with edges in the 'g_africa' graph\nedge_attr_names(g_africa)\n\n[1] \"l\"       \"h\"       \"time\"    \"timeU\"   \"timeUCB\" \"border\" \n\n\nwhere “l” represents the length in kilometres by road segment and it considers curves, “h” is the type of edge (primary, highway, etc.), “time” is the estimated minutes to travel through the edge, considering different speeds for distinc types of road, “timeU” is also the estimated minutes to travel throgh the edge, but allowing extra time if the extrema of the edge are urban nodes, “timeUCB” allows extra time for edges that cross a border, “border” is a binary variable taking value 1 is it crosses a border and 0 otherwise and “added” is also a binary variable taking value 1 if an edge was artificially added to ensure the connectedness of the network and 0 otherwise.\n\n3.3.1 Visualising the African road network as a spatial network\nWhat does the African road network that we just built look like? We can find out very easily using the plot function. But in order to achieve a nice-looking graph, we need to play a bit with the values of the arguments of this function. For example, we will plot the size of the nodes according to the population of the cities that they represent. But some cities are orders of magnitude larger than others, which would relut in some gigantic nodes for a few cities and tiny ones for the majority. In order to weaken this effect, we first apply a scaling function that redefines the size of the nodes:\n\n# Calculate and assign a 'size' attribute to vertices in the 'g_africa' graph\n# The size is determined based on the population data ('Pop2015') of each vertex\nV(g_africa)$size <- 0.3*(V(g_africa)$Pop2015/40000)^0.5\n\nNow we are ready to plot the network, with a few extra modifications to the default plot in order to improve the appearance. As an exercise, you may want to try to plot the default visualisation by simply running plot(g_africa). If you do this, you will understand better why it is worth it spending some time playing with the values of the parameters in the plot function.\n\nplot(g_africa, vertex.size=V(g_africa)$size, edge.arrow.size=.15, edge.arrow.width=.2, edge.curved=0.1, edge.width=1, edge.color =\"gray90\",\nvertex.color=\"red\", vertex.frame.color=\"black\", vertex.frame.width=0.2,\nvertex.label=\" \", vertex.label.color=\"black\",\nvertex.label.cex=.65)"
  },
  {
    "objectID": "african-network.html#network-metrics",
    "href": "african-network.html#network-metrics",
    "title": "3  The African road network",
    "section": "3.4 Network metrics",
    "text": "3.4 Network metrics\nThe following metrics can help us obtain further insights into the network structure. They are also valuable as a way to characterise the network so it can later be compared to other networks or to itself through time.\n\n3.4.1 Density\n\n# Calculate the edge density of the 'g_africa' graph\n# Edge density is the ratio of the number of edges to the number of possible edges\n# Loops (self-edges) are excluded from the calculation\nedge_density(g_africa, loops=FALSE)\n\n[1] 0.0003381142\n\n\nThe edge density is approximately 0.00034, giving as an indication that the network is quite sparse, since out of all possible edges, only 0.034% are present.\n\n\n3.4.2 Reciprocity\n\n# Calculate the reciprocity of the edges in the 'g_africa' graph\nreciprocity(g_africa)\n\n[1] 1\n\n\nThe reciprocity of this undirected network is naturally 1 by definition.\n\n\n3.4.3 Degree\nWe can compute the degree of each node with the function degree. In order to visualise the results, we produce a histogram\n\n# Compute degree of the nodes given by v belonging to graph g_africa\ndeg <- degree(g_africa, v=V(g_africa))\n\n# Produces histogram of the frequency of nodes with a certain in-degree\nhist(deg, breaks = 50, main=\"Histogram of node degree\")\n\n\n\n\nWe observe that most nodes have degree 3. Nodes of degree 1 are terminal nodes. Nodes of degree 2 are relatively less common than those of degree 1 and 3. This is likely due to the method used to build the network, where all the transport nodes of degree 2 are eliminated in order to simplify the network. Beyond degree 4, it is relatively rare to find any nodes. From the histogram, we see the maximum degree observed in the network is 13. Below, we obtain the name of the node with the maximum degree as well as the value of the degree (13).\n\n# Retrieve the names of vertices in the 'g_africa' graph that have the highest degree\nV(g_africa)$agglosName[degree(g_africa) == max(degree(g_africa))]\n\n[1] \"Duduza Central\"\n\n# Retrieve the names of vertices (general names) in the 'g_africa' graph that have the highest degree\nhighest_degree_vertex_names <- V(g_africa)$name[degree(g_africa) == max(degree(g_africa))]\n\n# Calculate the degree of vertices with the highest degree in the 'g_africa' graph\ndegree(g_africa, v=highest_degree_vertex_names)\n\n2896 \n  13 \n\n\n\n\n3.4.4 Distances\nWe can compute the shortest path between any pair of nodes, for example, between Cairo and Lagos. We store the output of the shortest path function in a dataframe called df_shortest_path.\n\n# Calculate the shortest paths between two specific vertices in the 'g_africa' graph\n# The source vertex is \"Cairo\" and the target vertex is \"Lagos\"\n# The length of the edges is used as weight in this calculation\n# Both path nodes and edges are included in the output\ndf_shortest_path <- shortest_paths(g_africa,  from = V(g_africa)$agglosName==\"Cairo\", to = V(g_africa)$agglosName==\"Lagos\", predecessors=FALSE, weights=df_edges$l,  output = \"both\") \n\nIn this dataframe, the field “epath” stores the edges of the shortest path as a one-element list. We can extract the values of this list as the edge ids, which we then use to compute the total length of the shortest path between the two cities.\n\n# Retrieve the edge path indices from the first element of the 'epath' column in the 'df_shortest_path' data frame\nidx <- df_shortest_path$epath[[1]]\n\n# Retrieve the lengths of edges along the path using the 'edge_attr' function and 'g_africa' graph\nlengths_epath <- edge_attr(g_africa, \"l\", idx)\n\n# Calculate the sum of edge lengths along the path\nsum(lengths_epath)\n\n[1] 6084.359\n\n\nWe obtain that the shortest path is 6,084.359 km long. You can check for example on Google Maps what the distance by road is between the two cities. What do you obtain? What is the relative error between our estimation and the value from Google Maps?\nThe diameter of the African road network is the length of the longest shortest path between any pair of nodes:\n\ndiameter(g_africa, directed=TRUE, weights=NA)\n\n[1] 138\n\n\nAnd the mean distance computed over all the pairs of nodes is:\n\nmean_distance(g_africa, directed=TRUE, weights=NA)\n\n[1] 55.8602\n\n\n\n\n3.4.5 Centrality\nBelow we compute the closeness centrality using unweighted edges and represent the results in a histogram. The distribution looks bimodal. From the visualisation of the network that we obtained above, why do you think this is the case?\n\n# Calculate the closeness centrality for each vertex in the 'g_africa' graph, using unweighted edges (weights = NA)\nclose_centr <- closeness(g_africa, weights = NA)\n\n# Create a histogram of closeness centrality values with 50 breaks and set the main title\nhist(close_centr, breaks = 50, main = \"Histogram of closeness centrality\")\n\n\n\n\nSimilarly, we also compute the betweenness centrality for all nodes and represent it as a histogram.\n\n# Calculate the betweenness centrality for each vertex in the 'g_africa' graph\nbetween_centr <- betweenness(g_africa, v = V(g_africa), directed = TRUE, weights = NA)\n\n# Create a histogram of betweenness centrality values with 30 breaks and set the main title\nhist(between_centr, breaks = 30, main = \"Histogram of betweenness centrality\")\n\n\n\n\n\n\n3.4.6 Communities\nOne way of detecting communities in networks is by using modularity-based methods. Modularity measures the concentration of edges between groups of nodes compared to what we would expect if the edges were placed at random.\nAn example of a modularity-based method is the fast greedy algorithm (Newman 2004), which starts with the original network but with no edges, so there are as many communities as nodes. Then, in each iteration of the algorithm a randomly chosen edge from the original network is placed back. The selected quality measure, in this case modularity, is evaluated. The added edge is retained if it increases the value of the modularity, or discarded otherwise. The process is repeated until the modularity function is maximised.\nWe can test this algorithm for the African road network and plot the result to see how the nodes are assigned to different communities (note that a node can belong to more than one community):\n\n# Detect clusters using the fast greedy algorithm on the 'g_africa' graph\nclusters <- cluster_fast_greedy(g_africa)\n\n# Create a plot of the 'g_africa' graph with specific visual attributes\nplot(g_africa, \n     vertex.size = V(g_africa)$size,          # Set vertex size based on the 'size' attribute\n     edge.arrow.size = 0.15,                 # Set arrow size for directed edges\n     edge.arrow.width = 0.2,                # Set arrow width for directed edges\n     edge.curved = 0.1,                     # Set edge curvature\n     edge.width = 1,                        # Set edge width\n     edge.color = \"gray90\",                 # Set edge color\n     vertex.color = membership(clusters),   # Set vertex color based on cluster membership\n     vertex.frame.color = \"black\",          # Set vertex frame (border) color\n     vertex.frame.width = 0.2,              # Set vertex frame (border) width\n     vertex.label = \" \",                    # Set vertex labels to empty\n     vertex.label.color = \"black\",          # Set vertex label color\n     vertex.label.cex = 0.65)               # Set vertex label size\n\n\n\n\nCan you find some interesting patterns in these communities?\n\n\n\n\n\nMoriconi-Ebrard, François, Dominique Harre, and Philipp Heinrigs. 2016. Urbanisation Dynamics in West Africa 1950–2010. https://doi.org/https://doi.org/https://doi.org/10.1787/9789264252233-en.\n\n\nNewman, M. E. J. 2004. “Fast Algorithm for Detecting Community Structure in Networks.” Phys. Rev. E 69 (June): 066133. https://doi.org/10.1103/PhysRevE.69.066133.\n\n\n“Openstreetmap.org.” https://www.openstreetmap.org/.\n\n\nPrieto Curiel, Rafael, Carmen Cabrera-Arnau, and Steven Richard Bishop. 2022. “Scaling Beyond Cities.” Frontiers in Physics 10. https://doi.org/10.3389/fphy.2022.858307.\n\n\nPrieto-Curiel, Rafael, Inhoi Heo, Abel Schumann, and Philipp Heinrigs. 2022. “Constructing a Simplified Interurban Road Network Based on Crowdsourced Geodata.” MethodsX 9: 101845. https://doi.org/https://doi.org/10.1016/j.mex.2022.101845."
  },
  {
    "objectID": "percolation.html#dependencies",
    "href": "percolation.html#dependencies",
    "title": "4  Percolation theory",
    "section": "4.1 Dependencies",
    "text": "4.1 Dependencies\n\n# Load required packages\nlibrary(igraph)    # for network analysis\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\nlibrary(ggplot2)\nlibrary(ggraph)\nlibrary(patchwork)\nlibrary(tidygraph)\n\n\nAttaching package: 'tidygraph'\n\n\nThe following object is masked from 'package:igraph':\n\n    groups\n\n\nThe following object is masked from 'package:stats':\n\n    filter\n\nlibrary(RColorBrewer)"
  },
  {
    "objectID": "percolation.html#introduction",
    "href": "percolation.html#introduction",
    "title": "4  Percolation theory",
    "section": "4.2 Introduction",
    "text": "4.2 Introduction\nThe term percolation normally refers to the process whereby a fluid moves slowly through a porous material, for example, the percolation of rain water through rocks gives rise to aquifers. The study and modelling of this infiltration process in physics, chemistry and material science is known as percolation theory. If you think about it, a rock can be modelled as a three-dimensional lattice (if the rock was cube-shaped, this lattice would be like a Rubik cube but instead of being \\(3 \\times 3\\times 3\\), it is \\(n\\times n \\times n\\)). Then, the pores in the rock would be represented by “open sites” in this lattice (this would correspond to missing pieces in the Rubik cube) and the bits of the rock where there is material and therefore, no chance for the water to go through, would be represented by “closed sites” (this would correspond to pieces in the Rubik cube that are actually present). A typical question in percolation theory would then be as follows. If sites may be open with probability \\(p\\) or closed with probability \\(1-p\\) and these probabilities are assumed to be independent for each site, what is the probability that the water can go through the top to the bottom of the rock for a given value of \\(p\\)?\nIn recent decades, the mathematical study of percolation has been applied in a more general way, to understand the behavior of connected clusters or pathways in any system that can be modelled as a lattice or as a network. While the formulation of the percolation models varies slightly from lattices to networks, it follows the same principles. For example, let’s consider the spread of a certain pandemic, where contagion between two humans may take place with probability \\(p\\) if an infected individual spends more than 10 minutes at less than 2 meters away from a healthy one. Then, we can think of the pandemic as a fluid moving slowly, but instead of going through a porous rock, it goes through a social network of people. The people can be modelled as the nodes of the social network, and edges are present between two individuals if they spend long enough in close physical contact. Then, each edge or connection has an associated probability of contagion \\(p\\). Applying percolation theory, we could answer the question of “what are the chances that the pandemic makes its way from city A to city B given the structure of the network and the fact that the probability of contagion is \\(p\\)?”\nPercolation theory can therefore be used in a variety of contexts to better understand the properties of a system characterised by the connections between its components. Here, we use percolation models to improve our understanding of the structure and resilience of the African road network.\nAs before, we start by loading the data corresonding to the nodes and edges of the African road network:\n\n# Read edge and node data from URLs\ndf_edges <- read.csv(\"https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkEdges.csv\")\ndf_nodes <- read.csv(\"https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkNodes.csv\", encoding='UTF-8')\n\n\n# Filter the data frame df_nodes to only include rows where the 'Region' column is equal to \"South\"\ndf_nodes <- subset(df_nodes, Region == \"South\")\n\n\n# Filter the data frame df_edges to only include rows where the 'from' column is in the list of Agglomeration_ID values from df_nodes\ndf_edges <- subset(df_edges, from %in% df_nodes$Agglomeration_ID)\n\n# Filter the data frame df_edges to only include rows where the 'to' column is in the list of Agglomeration_ID values from df_nodes\ndf_edges <- subset(df_edges, to %in% df_nodes$Agglomeration_ID)\n\nAnd we create an undirected graph from these data frames:\n\n# Create an undirected graph 'G' from a data frame 'df_edges' representing edges and a data frame 'df_nodes' representing vertices\nG <- graph_from_data_frame(d = df_edges,\n                           vertices = df_nodes,\n                           directed = FALSE)\n\nAs before, we can visualise this network by running the code below\n\n# Assign a 'size' attribute to vertices in graph 'G' based on a function of population data\nV(G)$size <- 0.5*(V(G)$Pop2015/10000)^0.4\n\n# Plot the graph 'G' with specific visual attributes\nplot(G, \n     vertex.size = V(G)$size,          # Set vertex size based on the 'size' attribute\n     edge.arrow.size = 0.15,           # Set arrow size for directed edges\n     edge.arrow.width = 0.2,          # Set arrow width for directed edges\n     edge.curved = 0.1,               # Set edge curvature\n     edge.width = 1,                  # Set edge width\n     edge.color = \"gray90\",           # Set edge color\n     vertex.color = \"red\",            # Set vertex color\n     vertex.frame.color = \"black\",    # Set vertex frame (border) color\n     vertex.frame.width = 0.2,        # Set vertex frame (border) width\n     vertex.label = \" \",              # Set vertex labels to empty\n     vertex.label.color = \"black\",    # Set vertex label color\n     vertex.label.cex = 0.65)         # Set vertex label size"
  },
  {
    "objectID": "percolation.html#modelling-community-formation-in-the-african-road-network",
    "href": "percolation.html#modelling-community-formation-in-the-african-road-network",
    "title": "4  Percolation theory",
    "section": "4.3 Modelling community formation in the African road network",
    "text": "4.3 Modelling community formation in the African road network\nAt the end of the previous session, we used the fast greedy algorithm to detect communities based on the topology of the African road network. We used an R implementation of the fast greedy algorithm through the built-in function cluter_fast_greedy(). While a built-in function gives us results in a very straightforward way, it also makes the process less transparent. In this section, we implement a percolation theory approach to model the formation of communities of nodes (cities) as the connectivity properties of the network are varied.\n\n# Create a list to store the plots\nplots_list <- list()\ni=1\n\n# Iterate over thresholds\nfor (j in seq(60, 360, 60)) {\n  \n  df_edges_perco <- subset(df_edges, timeUCB < j)\n  \n  G_perco <- graph_from_data_frame(d = df_edges_perco,\n                           vertices = df_nodes,\n                           directed = FALSE)\n  \n  # Find connected components\n  component_info <- components(G_perco)\n\n  # Define a color palette for connected components (replace with your own colors)\n  component_colors <- rainbow(max(component_info$membership) + 1)\n\n  # Create a data frame with node names and corresponding colors\n  node_colors <- data.frame(\n    name = df_nodes$Agglomeration_ID,\n    color = component_colors[component_info$membership + 1]\n  )\n  \n  # For isolated nodes, assign gray color\n  isolated_nodes <- V(G_perco)[degree(G_perco) == 0]\n  # Assuming 'attribute_name' is the attribute you want to retrieve\n  attribute_values <- get.vertex.attribute(G_perco, \"AgglomerationID\")[isolated_nodes]\n\n  \n  node_colors$color[node_colors$name %in% attribute_values] <- \"gray\"\n  \n  # Assign a 'size' attribute to vertices in graph 'G' based on a function of population data\n  V(G_perco)$size <- 0.5*(V(G_perco)$Pop2015/10000)^0.4\n\n  custom_layout <- data.frame(\n  name = V(G_perco)$name,  # Node names from the graph\n  x = df_nodes$x,  # Custom x-coordinates\n  y = df_nodes$y   # Custom y-coordinates\n  )\n  \n  # Plot the graph 'G_' with specific visual attributes\n  plot <- ggraph(as_tbl_graph(G_perco), custom_layout) +\n    geom_edge_link() +\n    geom_node_point(aes(color = node_colors$color), \n                    size = V(G_perco)$size) +\n                    theme(legend.position = \"none\")\n    \n     # plot(G_perco, \n     # vertex.size = V(G_perco)$size,         # Set vertex size based on the 'size' attribute\n     # edge.arrow.size = 0.15,          # Set arrow size for directed edges\n     # edge.arrow.width = 0.2,          # Set arrow width for directed edges\n     # edge.curved = 0.1,               # Set edge curvature\n     # edge.width = 1,                  # Set edge width\n     # edge.color = \"gray90\",           # Set edge color\n     # vertex.color = colors[component_membership],            # Set vertex color\n     # vertex.frame.color = \"black\",    # Set vertex frame (border) color\n     # vertex.frame.width = 0.2,        # Set vertex frame (border) width\n     # vertex.label = \" \",              # Set vertex labels to empty\n     # vertex.label.color = \"black\",    # Set vertex label color\n     # vertex.label.cex = 0.65)         # Set vertex label size \n  \n  # Add the plot to the list\n  plots_list[[i]] <- plot\n  \n  i <- i+1\n}\n\n\nplots_list %>%\n  wrap_plots(nrow = 2) \n\nWarning: Using the `size` aesthetic in this geom was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` in the `default_aes` field and elsewhere instead."
  },
  {
    "objectID": "percolation.html#measuring-network-robustness",
    "href": "percolation.html#measuring-network-robustness",
    "title": "4  Percolation theory",
    "section": "4.4 Measuring network robustness",
    "text": "4.4 Measuring network robustness\n\n# Create an empty data frame to store component information\ncomponents <- data.frame(nodeID = integer(0), component = integer(0), threshold = integer(0), gcc = integer(0))\n\n# Create empty lists to store thresholds, gccs, and ncs\nthresholds <- list()\ngccs <- list()\nncs <- list()"
  },
  {
    "objectID": "percolation.html#original-by-removing",
    "href": "percolation.html#original-by-removing",
    "title": "4  Percolation theory",
    "section": "4.5 Original by removing",
    "text": "4.5 Original by removing\n\n# Iterate over thresholds\nfor (i in seq(0, max(df_edges$l))) {\n  # Create a copy of the graph G\n  G_ <- G \n  \n  # Find indices of edges with lengths greater than the current threshold (i)\n  edges_to_remove <- which(E(G_)$l > i)\n  \n  # Delete edges from G_ based on their indices\n  G_ <- delete_edges(G_, edges_to_remove)\n  \n  # Get connected components of the modified graph G_\n  connected_components <- components(G_)\n  \n  # Create a data frame 'df_threshold' containing node IDs, component indices,\n  # threshold values, and sizes of connected components\n  df_threshold <- data.frame(nodeID = df_nodes$Agglomeration_ID, component = connected_components$membership, threshold = rep(i, times= nrow(df_nodes)), gcc = rep(max(connected_components$csize), times= nrow(df_nodes)))\n  \n  # Append 'df_threshold' to the 'components' data frame\n  components <- rbind(components, df_threshold)\n  \n  # Append the current threshold value to the 'thresholds' list\n  thresholds <- append(thresholds, i)\n  \n  # Append the maximum connected component size to the 'gccs' list\n  gccs <- append(gccs, max(connected_components$csize))\n  \n  # Append the number of connected components to the 'ncs' list\n  ncs <- append(ncs, connected_components$no)\n}\n\n# Display the first few rows of the 'components' data frame\nhead(components)\n\n     nodeID component threshold gcc\n4220   4220         1         0   1\n2333   2333         2         0   1\n2915   2915         3         0   1\n8177   8177         4         0   1\n7356   7356         5         0   1\n3165   3165         6         0   1\n\n\n\n# Plot the threshold values on the x-axis and the maximum connected component sizes (gccs) on the y-axis\nplot(thresholds, gccs)\n\n\n\n\n\n# Plot the threshold values on the x-axis and the number of connected components (ncs) on the y-axis\nplot(thresholds, ncs)"
  }
]