[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "An Introduction to Network Analysis for GIS",
    "section": "",
    "text": "Welcome\nThis website hosts the materials for the workshop “An Introduction to Network Analysis for GIS”. The training workshop was designed by Dr Carmen Cabrera-Arnau and Prof Francisco Rowe, with contributions from Andrew Renninger, Valentina Marin Maureira and Dr Rafael Prieto Curiel.\nThe website is free to use and is licensed under the Attribution-NonCommercial-NoDerivatives 4.0 International.\n\n\nContact\n\nDr Carmen Cabrera-Arnau, Lecturer in Geographic Data Science\nc.cabrera-arnau [at] liverpool.ac.uk\nDepartment of Geography & Planning, University of Liverpool, UK",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "come-prepared.html#workshop-structure",
    "href": "come-prepared.html#workshop-structure",
    "title": "1  Come prepared",
    "section": "1.1 Workshop structure",
    "text": "1.1 Workshop structure\n\n\n\nTime\nActivity\n\n\n\n\n15 min\nWelcome, introduction to workshop activities\n\n\n20 min\nDownloading the workshop materials from Github\n\n\n35 min\nImporting libraries, network theory basics\n\n\n10 min\nComfort break\n\n\n45 min\nThe African road network\n\n\n45 min\nPercolation\n\n\n10 min\nWrap-up"
  },
  {
    "objectID": "come-prepared.html#before-the-workshop",
    "href": "come-prepared.html#before-the-workshop",
    "title": "1  Come prepared",
    "section": "1.1 Before the workshop",
    "text": "1.1 Before the workshop\n\n\n\n\n\n\nImportant\n\n\n\nPlease make sure you download and install the most recent version of R, RStudio and Quarto on the computer that you will be using during the workshop, and install the indicated R packages – see detailed instructions below.\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll three software packages are open and free to use.\n\n\nR\nYou can download R here. Make sure you select the appropriate version for your Operating System: Windows, MacOS (Apple silicon M1/M2 or older intel Macs). For example, if you use a macOS laptop with an M1 processor, click on ‘Download R for macOS’ and then, click the link to download the installer file (.pkg extension for macOS) under the header ‘For Apple silicon (M1/M2) Macs’. You can then open the installer and follow the instructions that you will be prompted with. For Windows users, click on ‘install R for the first time’ and follow the prompts.\nRStudio\nYou will also need to download RStudio Desktop (or simply RStudio), which is an integrated development environment to help you write code in R more easily. To download RStudio, follow this link and scroll down to the section titled ‘All Installers and Tarballs’. Download the appropriate installer file according to your Operating System. Then, open the installer and follow the installation instructions that you will be prompted with.\nQuarto\nDownload Quarto from this website. Quarto is a publishing system that will allow you to open and work on the computational notebooks for the workshop. On ‘Step 1’ on the website, download the version of Quarto that matches your Operating System. Open the installer file, run it and follow the prompts.\nR packages\nOnce you have installed R, you will need to install some R extensions, known as packages, that will be useful for the applications explored in this workshop. In this case, you only need to install one package:\n\nigraph\nsf\ntidyverse\nggplot2\nggraph\npatchwork\ntidygraph\nRColorBrewer\nrnaturalearth\n\nTo install any package, open RStudio. On the console window (normally at the bottom left), write the following command: install.packages(\"name of package\"). Make sure you replace “name of package” by the actual name of the package that you want to install e.g. install.packages(\"tidyverse\"). Then, press enter and repeat this process until you have installed all the packages in the list.\nIf there are several packages you need to install, you can also install them all at once by copying and running the code below:\n\nlist.of.packages.cran &lt;- c(\n   \"igraph\", \n   \"sf\",\n   \"tidyverse\",\n   \"ggplot2\",\n   \"ggraph\",\n   \"patchwork\",\n   \"tidygraph\",\n   \"RColorBrewer\",\n   \"rnaturalearth\"\n)\n\nnew.packages.cran &lt;- list.of.packages.cran[!(list.of.packages.cran %in% installed.packages()[,\"Package\"])]\nif(length(new.packages.cran)) install.packages(new.packages.cran)\n\nfor(i in 1:length(list.of.packages.cran)) {\n  library(list.of.packages.cran[i], character.only = T)\n}\n\nOnce your packages are installed, you will need to load them in order to be able to use it in your code. This can be done by copying and running the code below:\n\ndeps &lt;- list(\n   \"igraph\", \n   \"sf\",\n   \"tidyverse\",\n   \"ggplot2\",\n   \"ggraph\",\n   \"patchwork\",\n   \"tidygraph\",\n   \"RColorBrewer\",\n   \"rnaturalearth\"\n)\n\nfor(lib in deps){library(lib, character.only = TRUE)}\n\nOr you can load them one by one simply running, for example, library(igraph) for igraph.\n\n\n\n\n\n\nImportant\n\n\n\nFurther instructions on how to download the workshop material from Github will be given during the workshop."
  },
  {
    "objectID": "introduction-networks.html#dependencies",
    "href": "introduction-networks.html#dependencies",
    "title": "2  Introduction to the basics of network analysis",
    "section": "2.1 Dependencies",
    "text": "2.1 Dependencies\nWe first clean the environment and load all the libraries required for this section.\n\n# working with spatial data\nlibrary(sf)\n# data manipulation and visualisation\nlibrary(tidyverse)\n# network manipulation and analysis\nlibrary(igraph)"
  },
  {
    "objectID": "introduction-networks.html#creating-networks",
    "href": "introduction-networks.html#creating-networks",
    "title": "2  Introduction to the basics of network analysis",
    "section": "2.2 Creating networks",
    "text": "2.2 Creating networks\nNetworks are used as a tool to conceptualise many real-life situations where a group of items display connections among themselves, such as the friendships among members of a school year group, airline flights between cities or hyperlinks between websites. Generally, a network (or a graph) consists of nodes (a.k.a. vertices) and edges (a.k.a. links) which represent the connections between the nodes of the network.\n\n2.2.1 Starting from the basics\nTo understand the basic concepts and components of a network, we create a small example network in R using the igraph package. We create an undirected network of 5 nodes and 7 edges.\n\n# create a graph object\nnetwork &lt;- graph( \n  n = 5, # add number of nodes\n  edges = c(1,2, \n            2,3, \n            2,5, \n            3,1, \n            3,4, \n            4,5, \n            5,1), # add edges\n  directed = FALSE )\n\n# plot\nplot(network, \n     layout = layout.circle(network), # set layout\n     vertex.label = 1:5)\n\n\n\n\n\n\n\n\nIf the connections between the nodes of a network are non-reciprocal, the network is called directed.\n\n# create a graph object\nnetwork &lt;- graph( \n  n = 5, # add number of nodes\n  edges = c(1,2, \n            2,3, \n            2,5, \n            3,1, \n            3,4, \n            4,5, \n            5,1), # add edges\n  directed = TRUE )\n\n# plot\nplot(network, \n     layout = layout.circle(network), # set layout\n     vertex.label = 1:5)\n\n\n\n\n\n\n\n\nThe network can also be defined as a list containing pairs of nodes with labels. In that case we do not need to specify the number of nodes. We only specify the isolated nodes to be included.\n\n\n\n\n\n\nNote\n\n\n\nWe will describe the various arguments within plot which can be used to style your data visualisation\n\n\n\n# create a graph object\nnetwork_isolated &lt;- graph( \n  c(\"City 1\",\"City 2\", \n    \"City 2\",\"City 3\", \n    \"City 2\",\"City 5\", \n    \"City 3\",\"City 1\", \n    \"City 3\",\"City 4\", \n    \"City 4\",\"City 5\", \n    \"City 5\",\"City 1\"),\n  isolates=c(\"City 6\") # isolated node\n  )\n\n# plot\nplot(network_isolated, \n    layout = layout.circle(network_isolated),\n     vertex.frame.color=\"red\",\n     vertex.color=\"yellow\", \n     vertex.size=15,\n     vertex.label.color=\"black\",\n     vertex.label.cex=0.9, \n     vertex.label.dist=2.3, \n     edge.curved=0.3, \n     edge.arrow.size=.5, \n     edge.color = \"blue\"\n     ) \n\n\n\n\n\n\n\n\n\n\n2.2.2 Adding attributes\nWe can add attributes to individual components of the network. To add attributes to nodes, we need to access them:\n\nV(network_isolated)\n\n+ 6/6 vertices, named, from 4ae50a7:\n[1] City 1 City 2 City 3 City 5 City 4 City 6\n\n\nNode attribute names are automatically generated from the node labels we assigned.\n\nV(network_isolated)$name\n\n[1] \"City 1\" \"City 2\" \"City 3\" \"City 5\" \"City 4\" \"City 6\"\n\n\nAdditional node attributes can be added, such as population size:\n\nV(network_isolated)$population &lt;- c(92000, 549000, 1786000, 74000, 8000, 21000)\n\nWe can also access the edges:\n\nE(network_isolated)\n\n+ 7/7 edges from 4ae50a7 (vertex names):\n[1] City 1-&gt;City 2 City 2-&gt;City 3 City 2-&gt;City 5 City 3-&gt;City 1 City 3-&gt;City 4\n[6] City 4-&gt;City 5 City 5-&gt;City 1\n\n\nWe can add edge attributes, such as the number of people moving from an origin to a destination city. We call this attribute edge weight. The size of the connection between two places often represent their importance or “weight” in the network.\n\nE(network_isolated)$weight &lt;- c(2000, 5000, 1000, 1000, 4000, 3500, 7000)\n\nWe can examine the adjacency matrix of the network. The adjacency represents the presence of edges between different pairs of nodes. In our example, each row corresponds to an origin city and each column to a destination:\n\nnetwork_isolated[]\n\n6 x 6 sparse Matrix of class \"dgCMatrix\"\n       City 1 City 2 City 3 City 5 City 4 City 6\nCity 1      .   2000      .      .      .      .\nCity 2      .      .   5000   1000      .      .\nCity 3   1000      .      .      .   4000      .\nCity 5   7000      .      .      .      .      .\nCity 4      .      .      .   3500      .      .\nCity 6      .      .      .      .      .      .\n\n\nWe can also look at the existing node and edge attributes.\n\nvertex_attr(network_isolated)\n\n$name\n[1] \"City 1\" \"City 2\" \"City 3\" \"City 5\" \"City 4\" \"City 6\"\n\n$population\n[1]   92000  549000 1786000   74000    8000   21000\n\n\nAnd we can add network attributes:\n\nnetwork_isolated$title &lt;- \"Network of human mobility between cities\"\n\n\n\n2.2.3 Basic visualisation\nYou have already seen how we can visualise networks using the base R function plot(). We will now elaborate on how individual components of the network can be visually adjusted using specific parameters in the plot function. More sophisticated data visualisations can be produced integrating geographic information, see Chapter 5 in Rowe, Cabrera-Arnau, and Piestrostefani (2023), or using other packages such as ggraph in conjunction with ggplot2 as we will see in the section on Percolation.\n\nplot(network_isolated,\n     layout = layout.circle(network_isolated),\n     # adjust nodes\n     vertex.frame.color = \"gray90\",   # line colour\n     vertex.label.color = \"black\",    # label colour \n     vertex.label.cex = 1,            # label font size\n     vertex.label.dist = 3,           # label distance\n     vertex.color = \"yellow\",         # colour \n     vertex.size=10,                  # size\n     # adjust edges\n     edge.curved=0.3,     # curvature\n     edge.arrow.size=1.5,  # size\n     edge.arrow.width=.5,\n     edge.width=E(network_isolated)$weight/1000,\n     edge.color = \"gray\") # colour",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to the basics of network analysis</span>"
    ]
  },
  {
    "objectID": "introduction-networks.html#network-metrics",
    "href": "introduction-networks.html#network-metrics",
    "title": "2  Introduction to the basics of network analysis",
    "section": "2.3 Network metrics",
    "text": "2.3 Network metrics\nNext we will provide a brief description of commonly used metrics to analyse the basic structure of networks.\n\n2.3.1 Density\nThe density of a network refers to the proportion of existing edges over all possible edges. In a network with \\(n\\) nodes, the total number of possible edges is \\(n \\times (n-1)\\). A density equal to \\(1\\) corresponds to a situation where \\(n \\times (n-1)\\) edges are present. A network with no edges at all would have density equal to 0. We can obtain the density of a network by running the following code:\n\nedge_density(network_isolated, \n             loops=FALSE)\n\n[1] 0.2333333\n\n\n\n\n2.3.2 Reciprocity\nThe reciprocity in a directed network is the proportion of reciprocated connections between nodes (i.e. number of pairs of nodes with edges in both directions) from all the existing edges.\n\nreciprocity(network_isolated)\n\n[1] 0\n\n\n\n\n2.3.3 Degree\nThe degree of a node is the number of edges connected to it. The in-degree of a node in a directed network is the number of edges ending in a given node. The out-degree is the number of edges starting from a given node. The degree() function allows computing the degree of one or more nodes, and specifying the measures of interest i.e. the total degree, in-degree or out-degree.\n\n# compute in-degree\nnet_degree &lt;- degree(network_isolated, \n                     v=V(network_isolated), \n                     mode=\"in\")\n\n# display histogram of in-degree\nhist(net_degree, \n     breaks = 30, \n     main = \"Node in-degree\")\n\n\n\n\n\n\n\n\n\n\n2.3.4 Distance\nA path in a network between node \\(A\\) and node \\(B\\) is a sequence of edges joining distinct nodes, starting at node \\(A\\) and ending at node \\(B\\). In a directed path all edges follow the same direction.\nThe path length of a path between nodes \\(A\\) and \\(B\\) is generally defined as the number of edges forming this path. The shortest path is the minimum count of edges present to travel from \\(A\\) to \\(B\\).\nThe path length can be defined in alternative ways. For example, the path length can be defined as the sum of the weights of the edges forming a path if the edges are weighted.\nWe can use the function shortest_paths() to find the shortest path between a given pair of nodes:\n\nshortest_paths(network_isolated, \n               from = V(network_isolated)$name == \"City 1\",\n               to = V(network_isolated)$name == \"City 5\",\n               weights=NA, # if weights = NULL and a weight edge attribute is present, this is used.\n               output = \"both\",  # outputs are produced for both path nodes and edges\n               predecessors = FALSE,\n               inbound.edges = FALSE,\n               )\n\n$vpath\n$vpath[[1]]\n+ 3/6 vertices, named, from 4ae50a7:\n[1] City 1 City 2 City 5\n\n\n$epath\n$epath[[1]]\n+ 2/7 edges from 4ae50a7 (vertex names):\n[1] City 1-&gt;City 2 City 2-&gt;City 5\n\n\n$predecessors\nNULL\n\n$inbound_edges\nNULL\n\n\nOf all shortest paths in a network, the longest path length is the network diameter.\n\ndiameter(network_isolated, \n         directed=TRUE, \n         weights=NA)\n\n[1] 4\n\n\nThe mean distance is the average length of all shortest paths in the network. The mean distance will always be smaller or equal than the diameter.\n\nmean_distance(network_isolated, \n              directed=TRUE, \n              weights=NA)\n\n[1] 2\n\n\n\n\n2.3.5 Centrality\nCentrality metrics assign scores to nodes (and sometimes also edges) according to their position within a network. These metrics can be used to identify the most influential nodes.\nWe can measure the degree of a node as we did before, but we can also measure its weighted degree. This is known as the strength of a node and it is computed as the sum of edge weights linked to adjacent nodes. Both degree and strength are considered to be centrality metrics.\n\n# compute strength of network nodes\nnet_strength &lt;- strength(network_isolated, # network object\n                         vids = V(network_isolated), #  vertices\n                         mode = c(\"in\"), # “in” for in-degree\n                         loops = FALSE, # whether to loop the edge count\n                         weights = NULL # if weights = NULL and a weight edge attribute is present, this is used.\n)\n  \n# histogram \nhist(net_strength, \n     breaks = 50, \n     main=\"Histogram of node strength\")\n\n\n\n\n\n\n\n\nAnother two important centrality metrics are (1) closeness centrality, and (2) betweenness centrality. Closeness centrality is a measure of the shortest path length between a node and all the other nodes. For a given node, it is computed as the inverse of the average shortest paths between that node and every other node in the network. A node with closeness centrality close to 1 indicates that on average the node is very close to the other nodes in the network. A closeness centrality of 0 represents an isolated node.\n\nclose_centr &lt;- closeness(network_isolated, \n                         mode=\"in\", \n                         weights=NA) # using unweighted edges\n\nhist(close_centr, \n     breaks = 50, \n     main = \"Histogram of closeness centrality\")\n\n\n\n\n\n\n\n\nBetweenness centrality is a measure of the number of shortest paths going through a node. Nodes with high values of betweenness centrality indicates that they play a very important role in the overall connectivity of the network. Betweenness can also be computed for edges.\n\nbetween_centr &lt;- betweenness(network_isolated, \n                             v = V(network_isolated), \n                             directed = TRUE, \n                             weights = NA)\n\nhist(between_centr, \n     breaks = 50, \n     main = \"Histogram of betweenness centrality\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nRowe, Francisco, Carmen Cabrera-Arnau, and Elisabetta Piestrostefani. 2023. Population Science. population-science.net.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to the basics of network analysis</span>"
    ]
  },
  {
    "objectID": "african-network.html#dependencies",
    "href": "african-network.html#dependencies",
    "title": "3  The African road network",
    "section": "3.1 Dependencies",
    "text": "3.1 Dependencies\nWe first clean the environment and load all the libraries required for this section.\n\n# An R package for network manipulation and analysis\nlibrary(igraph)"
  },
  {
    "objectID": "african-network.html#data",
    "href": "african-network.html#data",
    "title": "3  The African road network",
    "section": "3.2 Data",
    "text": "3.2 Data\nHere, we work with a network of African roads constructed by considering all continental cities with more than 100,000 inhabitants as the nodes, obtained from (Moriconi-Ebrard, Harre, and Heinrigs 2016). The edges of the network were created based on the road infrastructure from OpenStreetMap (“Openstreetmap.org”), using all primary roads, highways and trunk roads. Each edge was constructed by measuring the physical distance of consecutive points that describe the intricate patterns of the roads. Thus, a reasonably good estimate of its road length is available for each edge. Additional nodes besides cities are needed to describe the road infrastructure, such as some road intersections. These nodes are labelled as “transport nodes” and help define possible routes between cities. Some transport nodes correspond to towns with less than 100,000 inhabitants, so they are labelled as attached to nearby cities. The urban network enables us to consider the existing roads in the continent and measure the travelling distance rather than the physical distance between cities. The constructed network is formed by 7,361 nodes (2,162 cities and 5,199 transport nodes) and 9,159 edges. For more details on how the network was built, see (Prieto-Curiel et al. 2022).\nThe network is connected, meaning that it is possible to find a sequence of nodes and existing roads linking any pair of cities, and therefore, it is also possible to find the shortest road distance between any two cities and define it as the network distance. The network consists of 361,000 km of road infrastructure and connects 461 million people living in African cities, representing roughly 39% of the continent’s population (Prieto Curiel, Cabrera-Arnau, and Bishop 2022).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>The African road network</span>"
    ]
  },
  {
    "objectID": "african-network.html#creating-a-network-from-data-frame",
    "href": "african-network.html#creating-a-network-from-data-frame",
    "title": "3  The African road network",
    "section": "3.3 Creating a network from data frame",
    "text": "3.3 Creating a network from data frame\nThe data that specifies the nodes and edges of the African road network is stored in two csv files, one for nodes and one for edges. This data can be loaded in two dataframes:\n\n# Read the CSV file containing network nodes data from a URL\ndf_nodes &lt;- read.csv(\"https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkNodes.csv\")\n\n# Read the CSV file containing network edges data from a URL\ndf_edges &lt;- read.csv(\"https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkEdges.csv\")\n\nWe can then create an undirected graph as an igraph object from the data frames corresponding to the nodes and edges:\n\n# Create a graph 'g_africa' from data frames 'df_edges' and 'df_nodes'\n# The graph is undirected (directed = FALSE)\ng_africa &lt;- graph_from_data_frame(d = df_edges,\n                                       vertices = df_nodes,\n                                       directed = FALSE)\n\nWe can have a look at the names of the vertex attributes, which are automatically taken from the columns in the df_nodes data frame:\n\n# Retrieve the attribute names associated with vertices in the 'g_africa' graph\nvertex_attr_names(g_africa)\n\n[1] \"name\"       \"agglosName\" \"x\"          \"y\"          \"Pop2015\"   \n[6] \"ISO3\"       \"Region\"     \"Between\"    \"degree\"    \n\n\nwhere “name” is the ID of each node in the network, “agglosName” is the name of the city represented by the node, it is set to “road” if the node is a transport node. “x” and “y” represent the coordinates of each node, “Pop2015” is the population of the city nodes, “ISO3” is the code for the country that each node is situated in, “Region” represents the region within the African continent that each node is situated in, and “Between” and “degree” represent the betweenness centrality and the degree of each node in the network, which we will also compute below.\nIn particular, we can look at the first few values of the attribute “name”:\n\n# Retrieve the first few vertex names from the 'g_africa' graph\nhead(V(g_africa)$name)\n\n[1] \"2320\" \"5199\" \"7098\" \"4220\" \"4858\" \"5331\"\n\n\nWe can also obtain the names of the edge attributes, which are taken from the columns in the df_edges data frame:\n\n# Retrieve the attribute names associated with edges in the 'g_africa' graph\nedge_attr_names(g_africa)\n\n[1] \"l\"       \"h\"       \"time\"    \"timeU\"   \"timeUCB\" \"border\" \n\n\nwhere “l” represents the length in kilometres by road segment and it considers curves, “h” is the type of edge (primary, highway, etc.), “time” is the estimated minutes to travel through the edge, considering different speeds for distinc types of road, “timeU” is also the estimated minutes to travel throgh the edge, but allowing extra time if the extrema of the edge are urban nodes, “timeUCB” allows extra time for edges that cross a border, “border” is a binary variable taking value 1 is it crosses a border and 0 otherwise and “added” is also a binary variable taking value 1 if an edge was artificially added to ensure the connectedness of the network and 0 otherwise.\n\n3.3.1 Visualising the African road network as a spatial network\nWhat does the African road network that we just built look like? We can find out very easily using the plot function. But in order to achieve a nice-looking graph, we need to play a bit with the values of the arguments of this function. For example, we will plot the size of the nodes according to the population of the cities that they represent. But some cities are orders of magnitude larger than others, which would relut in some gigantic nodes for a few cities and tiny ones for the majority. In order to weaken this effect, we first apply a scaling function that redefines the size of the nodes:\n\n# Calculate and assign a 'size' attribute to vertices in the 'g_africa' graph\n# The size is determined based on the population data ('Pop2015') of each vertex\nV(g_africa)$size &lt;- 0.3*(V(g_africa)$Pop2015/40000)^0.5\n\nNow we are ready to plot the network, with a few extra modifications to the default plot in order to improve the appearance. As an exercise, you may want to try to plot the default visualisation by simply running plot(g_africa). If you do this, you will understand better why it is worth it spending some time playing with the values of the parameters in the plot function.\n\nplot(g_africa, vertex.size=V(g_africa)$size, edge.arrow.size=.15, edge.arrow.width=.2, edge.curved=0.1, edge.width=1, edge.color =\"gray90\",\nvertex.color=\"red\", vertex.frame.color=\"black\", vertex.frame.width=0.2,\nvertex.label=\" \", vertex.label.color=\"black\",\nvertex.label.cex=.65)"
  },
  {
    "objectID": "african-network.html#network-metrics",
    "href": "african-network.html#network-metrics",
    "title": "3  The African road network",
    "section": "3.4 Network metrics",
    "text": "3.4 Network metrics\nThe following metrics can help us obtain further insights into the network structure. They are also valuable as a way to characterise the network so it can later be compared to other networks or to itself through time.\n\n3.4.1 Density\n\n# Calculate the edge density of the 'g_africa' graph\n# Edge density is the ratio of the number of edges to the number of possible edges\n# Loops (self-edges) are excluded from the calculation\nedge_density(g_africa, loops=FALSE)\n\n[1] 0.0003381142\n\n\nThe edge density is approximately 0.00034, giving as an indication that the network is quite sparse, since out of all possible edges, only 0.034% are present.\n\n\n3.4.2 Reciprocity\n\n# Calculate the reciprocity of the edges in the 'g_africa' graph\nreciprocity(g_africa)\n\n[1] 1\n\n\nThe reciprocity of this undirected network is naturally 1 by definition.\n\n\n3.4.3 Degree\nWe can compute the degree of each node with the function degree. In order to visualise the results, we produce a histogram\n\n# Compute degree of the nodes given by v belonging to graph g_africa\ndeg &lt;- degree(g_africa, v=V(g_africa))\n\n# Produces histogram of the frequency of nodes with a certain in-degree\nhist(deg, breaks = 50, main=\"Histogram of node degree\")\n\n\n\n\n\n\n\n\nWe observe that most nodes have degree 3. Nodes of degree 1 are terminal nodes. Nodes of degree 2 are relatively less common than those of degree 1 and 3. This is likely due to the method used to build the network, where all the transport nodes of degree 2 are eliminated in order to simplify the network. Beyond degree 4, it is relatively rare to find any nodes. From the histogram, we see the maximum degree observed in the network is 13. Below, we obtain the name of the node with the maximum degree as well as the value of the degree (13).\n\n# Retrieve the names of vertices in the 'g_africa' graph that have the highest degree\nV(g_africa)$agglosName[degree(g_africa) == max(degree(g_africa))]\n\n[1] \"Duduza Central\"\n\n# Retrieve the names of vertices (general names) in the 'g_africa' graph that have the highest degree\nhighest_degree_vertex_names &lt;- V(g_africa)$name[degree(g_africa) == max(degree(g_africa))]\n\n# Calculate the degree of vertices with the highest degree in the 'g_africa' graph\ndegree(g_africa, v=highest_degree_vertex_names)\n\n2896 \n  13 \n\n\n\n\n3.4.4 Distances\nWe can compute the shortest path between any pair of nodes, for example, between Cairo and Lagos. We store the output of the shortest path function in a dataframe called df_shortest_path.\n\n# Calculate the shortest paths between two specific vertices in the 'g_africa' graph\n# The source vertex is \"Cairo\" and the target vertex is \"Lagos\"\n# The length of the edges is used as weight in this calculation\n# Both path nodes and edges are included in the output\ndf_shortest_path &lt;- shortest_paths(g_africa,  from = V(g_africa)$agglosName==\"Cairo\", to = V(g_africa)$agglosName==\"Lagos\", predecessors=FALSE, weights=df_edges$l,  output = \"both\") \n\nIn this dataframe, the field “epath” stores the edges of the shortest path as a one-element list. We can extract the values of this list as the edge ids, which we then use to compute the total length of the shortest path between the two cities.\n\n# Retrieve the edge path indices from the first element of the 'epath' column in the 'df_shortest_path' data frame\nidx &lt;- df_shortest_path$epath[[1]]\n\n# Retrieve the lengths of edges along the path using the 'edge_attr' function and 'g_africa' graph\nlengths_epath &lt;- edge_attr(g_africa, \"l\", idx)\n\n# Calculate the sum of edge lengths along the path\nsum(lengths_epath)\n\n[1] 6084.359\n\n\nWe obtain that the shortest path is 6,084.359 km long. You can check for example on Google Maps what the distance by road is between the two cities. What do you obtain? What is the relative error between our estimation and the value from Google Maps?\nThe diameter of the African road network is the length of the longest shortest path between any pair of nodes:\n\ndiameter(g_africa, directed=FALSE, weights=NA)\n\n[1] 138\n\n\nAnd the mean distance computed over all the pairs of nodes is:\n\nmean_distance(g_africa, directed=FALSE, weights=NA)\n\n[1] 55.8602\n\n\n\n\n3.4.5 Centrality\nBelow we compute the closeness centrality using unweighted edges and represent the results in a histogram. The distribution looks bimodal.\n\n# Calculate the closeness centrality for each vertex in the 'g_africa' graph, using unweighted edges (weights = NA)\nclose_centr &lt;- closeness(g_africa, weights = NA)\n\n# Create a histogram of closeness centrality values with 50 breaks and set the main title\nhist(close_centr, breaks = 50, main = \"Histogram of closeness centrality\")\n\n\n\n\n\n\n\n\nSimilarly, we also compute the betweenness centrality for all nodes and represent it as a histogram.\n\n# Calculate the betweenness centrality for each vertex in the 'g_africa' graph\nbetween_centr &lt;- betweenness(g_africa, v = V(g_africa), directed = TRUE, weights = NA)\n\n# Create a histogram of betweenness centrality values with 30 breaks and set the main title\nhist(between_centr, breaks = 30, main = \"Histogram of betweenness centrality\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nHow would you interpret the patterns observed in the histograms for closeness centrality and betweenness centrality?\n\n\n\n\n\n\n\nMoriconi-Ebrard, François, Dominique Harre, and Philipp Heinrigs. 2016. Urbanisation Dynamics in West Africa 1950–2010. https://doi.org/https://doi.org/https://doi.org/10.1787/9789264252233-en.\n\n\n“Openstreetmap.org.” https://www.openstreetmap.org/.\n\n\nPrieto Curiel, Rafael, Carmen Cabrera-Arnau, and Steven Richard Bishop. 2022. “Scaling Beyond Cities.” Frontiers in Physics 10. https://doi.org/10.3389/fphy.2022.858307.\n\n\nPrieto-Curiel, Rafael, Inhoi Heo, Abel Schumann, and Philipp Heinrigs. 2022. “Constructing a Simplified Interurban Road Network Based on Crowdsourced Geodata.” MethodsX 9: 101845. https://doi.org/https://doi.org/10.1016/j.mex.2022.101845.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>The African road network</span>"
    ]
  },
  {
    "objectID": "percolation.html#dependencies",
    "href": "percolation.html#dependencies",
    "title": "4  Percolation theory",
    "section": "4.1 Dependencies",
    "text": "4.1 Dependencies\nWe first clean the environment and load all the libraries required for this section.\n\n# Load required packages\nlibrary(igraph)    # for network analysis\nlibrary(ggplot2)   # for data visualization\nlibrary(ggraph)    # for graph visualization\nlibrary(patchwork) # for arranging plots\nlibrary(tidygraph) # for tidy data handling with graphs\nlibrary(RColorBrewer) # for color palettes\nlibrary(rnaturalearth) # for natural earth map data\nlibrary(sf)        # for spatial data manipulation"
  },
  {
    "objectID": "percolation.html#introduction",
    "href": "percolation.html#introduction",
    "title": "4  Applications",
    "section": "5.4 Introduction",
    "text": "5.4 Introduction\nThe term percolation normally refers to the process whereby a fluid moves slowly through a porous material, for example, the percolation of rain water through rocks gives rise to aquifers. The study and modelling of this infiltration process in physics, chemistry and material science is known as percolation theory. If you think about it, a rock can be modelled as a three-dimensional lattice (if the rock was cube-shaped, this lattice would be like a Rubik cube but instead of being \\(3 \\times 3\\times 3\\), it is \\(n\\times n \\times n\\)). Then, the pores in the rock would be represented by “open sites” in this lattice (this would correspond to missing pieces in the Rubik cube) and the bits of the rock where there is material and therefore, no chance for the water to go through, would be represented by “closed sites” (this would correspond to pieces in the Rubik cube that are actually present). A typical question in percolation theory would then be as follows. If sites may be open with probability \\(p\\) or closed with probability \\(1-p\\) and these probabilities are assumed to be independent for each site, what is the probability that the water can go through the top to the bottom of the rock for a given value of \\(p\\)?\nIn recent decades, the mathematical study of percolation has been applied in a more general way, to understand the behavior of connected clusters or pathways in any system that can be modelled as a lattice or as a network. While the formulation of the percolation models varies slightly from lattices to networks, it follows the same principles. For example, let’s consider the spread of a certain pandemic, where contagion between two humans may take place with probability \\(p\\) if an infected individual spends more than 10 minutes at less than 2 meters away from a healthy one. Then, we can think of the pandemic as a fluid moving slowly, but instead of going through a porous rock, it goes through a social network of people. The people can be modelled as the nodes of the social network, and edges are present between two individuals if they spend long enough in close physical contact. Then, each edge or connection has an associated probability of contagion \\(p\\). Applying percolation theory, we could answer the question of “what are the chances that the pandemic makes its way from city A to city B given the structure of the network and the fact that the probability of contagion is \\(p\\)?”\nPercolation theory can therefore be used in a variety of contexts to better understand the properties of a system characterised by the connections between its components. Here, we use percolation models to improve our understanding of the structure and resilience of the African road network.\nAs before, we start by loading the data corresponding to the nodes and edges of the African road network:\n\n# Read CSV data for edges from a specified URL\ndf_edges &lt;- read.csv(\"./data/AfricaNetworkEdges.csv\")\n\n# Read CSV data for nodes from a specified URL, specifying UTF-8 encoding for special characters\ndf_nodes &lt;- read.csv(\"./data/AfricaNetworkNodes.csv\", encoding='UTF-8')\n\nIn order to ensure timely completion of this workshop, we will use a subset of the African network, specifically focusing on nodes from the South region. This adjustment is necessary as running the code on the entire network would exceed the allocated time frame. However, you are encouraged to explore running the code on the complete network at your own convenience.\nWe start by selecting the nodes belonging to the South region. This can be easily done with the subset() function.\n\n# Subset the df_nodes data frame to include only rows where Region is \"South\"\ndf_nodes &lt;- subset(df_nodes, Region == \"South\")\n\nSimilarly, we can select the only the edges where both extrema are nodes belonging to the South region.\n\n# Subset df_edges to include only rows where 'from' column values are in df_nodes$Agglomeration_ID\ndf_edges &lt;- subset(df_edges, from %in% df_nodes$Agglomeration_ID)\n\n# Subset df_edges to include only rows where 'to' column values are in df_nodes$Agglomeration_ID\ndf_edges &lt;- subset(df_edges, to %in% df_nodes$Agglomeration_ID)\n\nLike before, we can create an undirected graph from the redefined data frames of nodes and edges.\n\n# Create an igraph graph 'G' from data frames 'df_edges' and 'df_nodes'\nG &lt;- graph_from_data_frame(d = df_edges,\n                           vertices = df_nodes,\n                           directed = FALSE)\n\nWe can visualise this sub-network by running the code below. Note that instead of using the base R function plot(), we are now using ggraph, which is an R package used for creating and visualising graphs and networks. It is built on top of the popular ggplot2 package, which is used for creating a wider range of statistical graphics in R.\n\n# Set node sizes in the graph 'G' based on a function of population size\nV(G)$size &lt;- 0.5*(V(G)$Pop2015/10000)^0.4\n\n# Create a custom layout data frame with node names, x-coordinates, and y-coordinates\ncustom_layout &lt;- data.frame(\n  name = V(G)$name,  # Node names from the graph\n  x = df_nodes$x,    # Custom x-coordinates\n  y = df_nodes$y    # Custom y-coordinates\n)\n\n# Plot the graph 'G' with specific visual attributes\nplotG &lt;- ggraph(as_tbl_graph(G), custom_layout) +\n  geom_edge_link() +\n  geom_node_point(aes(colour=\"red\", size=V(G)$size)) +\n  theme(legend.position = \"none\") +\n  coord_fixed()\n\n# Display the graph plotG\nplotG\n\n\n\n\n\n\n\n\nThe countries belonging to the South region are Botswana, Eswatini, Lesotho, Namibia, South Africa. To give more geographical context to the above visualisation, we will add the outlines of these countries as a base layer for this plot. The shapes for the world countries can be downloaded as simple feature objects (similar to a data frame but it also includes geographic information) using the ne_download function from the rnaturalearth package. We store the simple feature in the variable world, which we then filter to include only the countries of interest.\n\n# Download world map data with specified parameters\nworld &lt;- ne_download(scale = \"small\", category = \"cultural\", type = \"admin_0_countries\", returnclass = \"sf\")\n\nReading layer `ne_110m_admin_0_countries' from data source \n  `/private/var/folders/79/65l52xsj7vq_4_t_l6k5bl2c0000gn/T/Rtmpt88c2l/ne_110m_admin_0_countries.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 177 features and 168 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n\n# Define a vector of target countries\ntarget_countries &lt;- c(\"Botswana\", \"eSwatini\", \"Lesotho\", \"Namibia\", \"South Africa\")\n\n# Subset the world map data to include only the target countries\nworld_subset &lt;- world[world$SOVEREIGNT %in% target_countries, ]\n\nThe plot from above can be modified to also include the base layer\n\n# Plot the graph 'G' with specific visual attributes\nplotG &lt;- ggraph(as_tbl_graph(G), custom_layout) +\n  geom_edge_link() +\n  geom_node_point(aes(colour=\"red\", size=V(G)$size)) +\n  theme(legend.position = \"none\") +\n  geom_sf(data = world_subset, fill = NA, color = \"black\") \n\n# Display the graph plotG\nplotG",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#modelling-community-formation-in-the-african-road-network",
    "href": "percolation.html#modelling-community-formation-in-the-african-road-network",
    "title": "4  Percolation theory",
    "section": "4.3 Modelling community formation in the African road network",
    "text": "4.3 Modelling community formation in the African road network\nIn this section, we implement a percolation theory approach to model the formation of communities of nodes (cities) as the connectivity properties of the network are varied.\n\n4.3.1 Percolation at three threshold values\nFollowing a percolation approach, we start with the original network representing the cities and roads of the Southern African region, but with no edges. Then, we add back edges according to whether they satisfy a certain criterion. In this case, an edge is added back if the time to travel from one end to the other considering the presence of a border is below a threshold value (i.e. if the attribute timeUCB is below a certain threshold value). Below, we perform this process for three different values of the percolation parameter given by timeUCB, which are 60, 120 and 180 minutes.\n\n# Create a copy of df_nodes named df_nodes_perco_60\ndf_nodes_perco_60 &lt;- df_nodes\n\n# Subset df_edges to include only rows where timeUCB is less than 60\ndf_edges_perco_60 &lt;- subset(df_edges, timeUCB &lt; 60)\n\n# Create a graph G_perco_60 from the modified data frames\nG_perco_60 &lt;- graph_from_data_frame(d = df_edges_perco_60,\n                                    vertices = df_nodes_perco_60,\n                                    directed = FALSE)\n\n\n# Create a copy of df_nodes named df_nodes_perco_120\ndf_nodes_perco_120 &lt;- df_nodes\n\n# Subset df_edges to include only rows where timeUCB is less than 120\ndf_edges_perco_120 &lt;- subset(df_edges, timeUCB &lt; 120)\n\n# Create a graph G_perco_120 from the modified data frames\nG_perco_120 &lt;- graph_from_data_frame(d = df_edges_perco_120,\n                                    vertices = df_nodes_perco_120,\n                                    directed = FALSE)\n\n\n# Create a copy of df_nodes named df_nodes_perco_180\ndf_nodes_perco_180 &lt;- df_nodes\n\n# Subset df_edges to include only rows where timeUCB is less than 180\ndf_edges_perco_180 &lt;- subset(df_edges, timeUCB &lt; 180)\n\n# Create a graph G_perco_180 from the modified data frames\nG_perco_180 &lt;- graph_from_data_frame(d = df_edges_perco_180,\n                                    vertices = df_nodes_perco_180,\n                                    directed = FALSE)\n\n\n\n4.3.2 Visualising the results\nWe also obtain visualisations for the three threshold travel times. In these visualisations, we color the nodes so that nodes belonging to the same connected component share the same color. A connected component is a group of nodes where you can travel from any node to any other node by following the edges. We store the visualisations for each of the three critical travel times in the variables plot_60, plot_120 and plot_180. Then, we plot them together using the patchwork package, which allows to create figures with several plots simply by running plot_60 + plot_120 + plot_180.\n\n# Find connected components in G_perco_60\ncomponent_info_60 &lt;- components(G_perco_60)\n\n# Create a data frame with node names and their corresponding connected component IDs\ndf_nodes_perco_60$component_ID &lt;- component_info_60$membership\n\n# Define a color palette for connected components (replace with your own colors if desired)\ncomponent_colors_60 &lt;- sample(rainbow(component_info_60$no), replace=FALSE)\n\n# Assign colors to nodes based on their connected component\nnode_colors_60 &lt;- component_colors_60[component_info_60$membership]\n\n# Add color information to the df_nodes_perco_60 data frame\ndf_nodes_perco_60$color &lt;- node_colors_60\n\n# Calculate and add degree information to the df_nodes_perco_60 data frame\ndf_nodes_perco_60$degree &lt;- degree(G_perco_60)\n\n# Set nodes with degree 0 to gray color\ndf_nodes_perco_60$color[df_nodes_perco_60$degree == 0] &lt;- \"gray\"\n\n# Set node sizes in G_perco_60 based on a function of population size\nV(G_perco_60)$size &lt;- 0.5*(V(G_perco_60)$Pop2015/10000)^0.4\n\n# Create a custom layout data frame with node names, x-coordinates, and y-coordinates\ncustom_layout &lt;- data.frame(\n  name = V(G_perco_60)$name,  # Node names from the graph\n  x = df_nodes_perco_60$x,    # Custom x-coordinates\n  y = df_nodes_perco_60$y     # Custom y-coordinates\n)\n\n# Plot the graph 'G_perco_60' with specific visual attributes\nplot_60 &lt;- ggraph(as_tbl_graph(G_perco_60), custom_layout) +\n  geom_edge_link() +\n  geom_node_point(aes(color = df_nodes_perco_60$color, \n                      size = V(G_perco_60)$size)) +\n  scale_color_identity() +\n  theme(legend.position = \"none\") +\n  geom_sf(data = world_subset, fill = NA, color = \"black\") +\n  labs(title = \"timeUCB &lt; 60\")\n\n\n# Find connected components in G_perco_120\ncomponent_info_120 &lt;- components(G_perco_120)\n\n# Create a data frame with node names and their corresponding connected component IDs\ndf_nodes_perco_120$component_ID &lt;- component_info_120$membership\n\n# Define a color palette for connected components (replace with your own colors if desired)\ncomponent_colors_120 &lt;- sample(rainbow(component_info_120$no), replace=FALSE)\n\n# Assign colors to nodes based on their connected component\nnode_colors_120 &lt;- component_colors_120[component_info_120$membership]\n\n# Add color information to the df_nodes_perco_120 data frame\ndf_nodes_perco_120$color &lt;- node_colors_120\n\n# Calculate and add degree information to the df_nodes_perco_120 data frame\ndf_nodes_perco_120$degree &lt;- degree(G_perco_120)\n\n# Set nodes with degree 0 to gray color\ndf_nodes_perco_120$color[df_nodes_perco_120$degree == 0] &lt;- \"gray\"\n\n# Set node sizes in G_perco_120 based on a function of population size\nV(G_perco_120)$size &lt;- 0.5*(V(G_perco_120)$Pop2015/10000)^0.4\n\n# Create a custom layout data frame with node names, x-coordinates, and y-coordinates\ncustom_layout &lt;- data.frame(\n  name = V(G_perco_120)$name,  # Node names from the graph\n  x = df_nodes_perco_120$x,    # Custom x-coordinates\n  y = df_nodes_perco_120$y     # Custom y-coordinates\n)\n\n# Plot the graph 'G_perco_120' with specific visual attributes\nplot_120 &lt;- ggraph(as_tbl_graph(G_perco_120), custom_layout) +\n  geom_edge_link() +\n  geom_node_point(aes(color = df_nodes_perco_120$color, \n                      size = V(G_perco_120)$size)) +\n  scale_color_identity() +\n  theme(legend.position = \"none\") +\n  geom_sf(data = world_subset, fill = NA, color = \"black\") +\n  labs(title = \"timeUCB &lt; 120\")\n\n\n# Find connected components in G_perco_180\ncomponent_info_180 &lt;- components(G_perco_180)\n\n# Create a data frame with node names and their corresponding connected component IDs\ndf_nodes_perco_180$component_ID &lt;- component_info_180$membership\n\n# Define a color palette for connected components (replace with your own colors if desired)\ncomponent_colors_180 &lt;- sample(rainbow(component_info_180$no), replace=FALSE)\n\n# Assign colors to nodes based on their connected component\nnode_colors_180 &lt;- component_colors_180[component_info_180$membership]\n\n# Add color information to the df_nodes_perco_180 data frame\ndf_nodes_perco_180$color &lt;- node_colors_180\n\n# Calculate and add degree information to the df_nodes_perco_180 data frame\ndf_nodes_perco_180$degree &lt;- degree(G_perco_180)\n\n# Set nodes with degree 0 to gray color\ndf_nodes_perco_180$color[df_nodes_perco_180$degree == 0] &lt;- \"gray\"\n\n# Set node sizes in G_perco_180 based on a function of population size\nV(G_perco_180)$size &lt;- 0.5*(V(G_perco_180)$Pop2015/10000)^0.4\n\n# Create a custom layout data frame with node names, x-coordinates, and y-coordinates\ncustom_layout &lt;- data.frame(\n  name = V(G_perco_180)$name,  # Node names from the graph\n  x = df_nodes_perco_180$x,    # Custom x-coordinates\n  y = df_nodes_perco_180$y     # Custom y-coordinates\n)\n\n# Plot the graph 'G_perco_180' with specific visual attributes\nplot_180 &lt;- ggraph(as_tbl_graph(G_perco_180), custom_layout) +\n  geom_edge_link() +\n  geom_node_point(aes(color = df_nodes_perco_180$color, \n                      size = V(G_perco_180)$size)) +\n  scale_color_identity() +\n  theme(legend.position = \"none\") +\n  geom_sf(data = world_subset, fill = NA, color = \"black\") +\n  labs(title = \"timeUCB &lt; 180\")\n\n\n# Combine the plots for G_perco_60, G_perco_120, and G_perco_180\nplot_60 + plot_120 + plot_180"
  },
  {
    "objectID": "percolation.html#measuring-network-robustness",
    "href": "percolation.html#measuring-network-robustness",
    "title": "4  Percolation theory",
    "section": "4.4 Measuring network robustness",
    "text": "4.4 Measuring network robustness\n\n# Create an empty data frame to store component information\ncomponents <- data.frame(nodeID = integer(0), component = integer(0), threshold = integer(0), gcc = integer(0))\n\n# Create empty lists to store thresholds, gccs, and ncs\nthresholds <- list()\ngccs <- list()\nncs <- list()"
  },
  {
    "objectID": "percolation.html#original-by-removing",
    "href": "percolation.html#original-by-removing",
    "title": "4  Percolation theory",
    "section": "4.5 Original by removing",
    "text": "4.5 Original by removing\n\n# Iterate over thresholds\nfor (i in seq(0, max(df_edges$l))) {\n  # Create a copy of the graph G\n  G_ <- G \n  \n  # Find indices of edges with lengths greater than the current threshold (i)\n  edges_to_remove <- which(E(G_)$l > i)\n  \n  # Delete edges from G_ based on their indices\n  G_ <- delete_edges(G_, edges_to_remove)\n  \n  # Get connected components of the modified graph G_\n  connected_components <- components(G_)\n  \n  # Create a data frame 'df_threshold' containing node IDs, component indices,\n  # threshold values, and sizes of connected components\n  df_threshold <- data.frame(nodeID = df_nodes$Agglomeration_ID, component = connected_components$membership, threshold = rep(i, times= nrow(df_nodes)), gcc = rep(max(connected_components$csize), times= nrow(df_nodes)))\n  \n  # Append 'df_threshold' to the 'components' data frame\n  components <- rbind(components, df_threshold)\n  \n  # Append the current threshold value to the 'thresholds' list\n  thresholds <- append(thresholds, i)\n  \n  # Append the maximum connected component size to the 'gccs' list\n  gccs <- append(gccs, max(connected_components$csize))\n  \n  # Append the number of connected components to the 'ncs' list\n  ncs <- append(ncs, connected_components$no)\n}\n\n# Display the first few rows of the 'components' data frame\nhead(components)\n\n     nodeID component threshold gcc\n4220   4220         1         0   1\n2333   2333         2         0   1\n2915   2915         3         0   1\n8177   8177         4         0   1\n7356   7356         5         0   1\n3165   3165         6         0   1\n\n\n\n# Plot the threshold values on the x-axis and the maximum connected component sizes (gccs) on the y-axis\nplot(thresholds, gccs)\n\n\n\n\n\n# Plot the threshold values on the x-axis and the number of connected components (ncs) on the y-axis\nplot(thresholds, ncs)"
  },
  {
    "objectID": "percolation.html#analysing-network-robustness",
    "href": "percolation.html#analysing-network-robustness",
    "title": "4  Percolation theory",
    "section": "4.4 Analysing network robustness",
    "text": "4.4 Analysing network robustness\n\n4.4.1 Changes in the size of the giant connected component as edges are removed\n\n# Create an empty data frame to store component information\ncomponents &lt;- data.frame(nodeID = integer(0), component = integer(0), threshold = integer(0), gcc = integer(0))\n\n# Create empty lists to store thresholds, gccs, and ncs\nthresholds &lt;- list()\ngccs &lt;- list()\nncs &lt;- list()\n\n\n# Iterate over thresholds\nfor (i in seq(0, max(df_edges$l))) {\n  # Create a copy of the graph G\n  G_ &lt;- G \n  \n  # Find indices of edges with lengths greater than the current threshold (i)\n  edges_to_remove &lt;- which(E(G_)$l &gt; i)\n  \n  # Delete edges from G_ based on their indices\n  G_ &lt;- delete_edges(G_, edges_to_remove)\n  \n  # Get connected components of the modified graph G_\n  connected_components &lt;- components(G_)\n  \n  # Create a data frame 'df_threshold' containing node IDs, component indices,\n  # threshold values, and sizes of connected components\n  df_threshold &lt;- data.frame(nodeID = df_nodes$Agglomeration_ID, component = connected_components$membership, threshold = rep(i, times= nrow(df_nodes)), gcc = rep(max(connected_components$csize), times= nrow(df_nodes)))\n  \n  # Append 'df_threshold' to the 'components' data frame\n  components &lt;- rbind(components, df_threshold)\n  \n  # Append the current threshold value to the 'thresholds' list\n  thresholds &lt;- append(thresholds, i)\n  \n  # Append the maximum connected component size to the 'gccs' list\n  gccs &lt;- append(gccs, max(connected_components$csize))\n  \n  # Append the number of connected components to the 'ncs' list\n  ncs &lt;- append(ncs, connected_components$no)\n}\n\n# Display the first few rows of the 'components' data frame\nhead(components)\n\n     nodeID component threshold gcc\n4220   4220         1         0   1\n2333   2333         2         0   1\n2915   2915         3         0   1\n8177   8177         4         0   1\n7356   7356         5         0   1\n3165   3165         6         0   1\n\n\n\n# Plot the threshold values on the x-axis and the maximum connected component sizes (gccs) on the y-axis\nplot(thresholds, gccs)\n\n\n\n\n\n# Plot the threshold values on the x-axis and the number of connected components (ncs) on the y-axis\nplot(thresholds, ncs)\n\n\n\n\n\n\n4.4.2 Changes in the average distance as nodes are removed\n\n# Create empty lists to store thresholds, gccs, and ncs\npopulations &lt;- list()\naverage_distances &lt;- list()\n\n\n# Iterate over thresholds\nfor (node_id in V(G)) {\n  \n  # Retrieve the population attribute for the current node\n  populations &lt;- append(populations, V(G)[node_id]$Pop2015)\n  \n  # Create a copy of the graph G\n  G_ &lt;- G \n  \n  # Find indices of edges with lengths greater than the current threshold (i)\n  G_ &lt;- delete_vertices(G_, node_id)\n  \n  average_distance &lt;- mean_distance(G_)\n  \n  average_distances &lt;- append(average_distances, average_distance)\n  \n}\n\n\nplot(populations, average_distances)"
  },
  {
    "objectID": "african-network.html#creating-a-network-from-a-data-frame",
    "href": "african-network.html#creating-a-network-from-a-data-frame",
    "title": "3  The African road network",
    "section": "3.3 Creating a network from a data frame",
    "text": "3.3 Creating a network from a data frame\nThe data that specifies the nodes and edges of the African road network is stored in two csv files, one for nodes and one for edges. The dataframes can be found at https://github.com/CrmnCA/nets4gis within the data folder. This data can be loaded in two data frames:\n\n# Read the CSV file containing network nodes data from a URL\ndf_nodes &lt;- read.csv(\"./data/AfricaNetworkNodes.csv\")\n\n# Read the CSV file containing network edges data from a URL\ndf_edges &lt;- read.csv(\"./data/AfricaNetworkEdges.csv\")\n\nWe can then create an undirected graph as an igraph object from the data frames corresponding to the nodes and edges:\n\n# Create a graph 'g_africa' from data frames 'df_edges' and 'df_nodes'\n# The graph is undirected (directed = FALSE)\ng_africa &lt;- graph_from_data_frame(d = df_edges,\n                                       vertices = df_nodes,\n                                       directed = FALSE)\n\nWe can have a look at the names of the vertex attributes, which are automatically taken from the columns in the df_nodes data frame:\n\n# Retrieve the attribute names associated with vertices in the 'g_africa' graph\nvertex_attr_names(g_africa)\n\n[1] \"name\"       \"agglosName\" \"x\"          \"y\"          \"Pop2015\"   \n[6] \"ISO3\"       \"Region\"     \"Between\"    \"degree\"    \n\n\nwhere “name” is the ID of each node in the network, “agglosName” is the name of the city represented by the node, it is set to “road” if the node is a transport node. “x” and “y” represent the coordinates of each node, “Pop2015” is the population of the city nodes, “ISO3” is the code for the country that each node is situated in, “Region” represents the region within the African continent that each node is situated in, and “Between” and “degree” represent the betweenness centrality and the degree of each node in the network, which we will also compute below.\nIn particular, we can look at the first few values of any node attribute, for examples “Pop2015”:\n\n# Retrieve the first few vertex names from the 'g_africa' graph\nhead(V(g_africa)$Pop2015)\n\n[1] 22995802 11847635  8530514  8314220  7270000  6979211\n\n\nWe can also obtain the names of the edge attributes, which are taken from the columns in the df_edges data frame:\n\n# Retrieve the attribute names associated with edges in the 'g_africa' graph\nedge_attr_names(g_africa)\n\n[1] \"l\"       \"h\"       \"time\"    \"timeU\"   \"timeUCB\" \"border\" \n\n\nwhere “l” represents the length in kilometres by road segment and it considers curves, “h” is the type of edge (primary, highway, etc.), “time” is the estimated minutes to travel through the edge, considering different speeds for distinc types of road, “timeU” is also the estimated minutes to travel through the edge, but allowing extra time if the extrema of the edge are urban nodes, “timeUCB” allows extra time for edges that cross a border, “border” is a binary variable taking value 1 is it crosses a border and 0 otherwise and “added” is also a binary variable taking value 1 if an edge was artificially added to ensure the connectedness of the network and 0 otherwise.\n\n3.3.1 Visualising the African road network as a spatial network\nWhat does the African road network that we just built look like? We can find out very easily using the plot function. But in order to achieve a nice-looking graph, we need to play a bit with the values of the arguments of this function. For example, we will plot the size of the nodes according to the population of the cities that they represent. But some cities are orders of magnitude larger than others, which would relut in some gigantic nodes for a few cities and tiny ones for the majority. In order to weaken this effect, we first apply a scaling function that redefines the size of the nodes:\n\n# Calculate and assign a 'size' attribute to vertices in the 'g_africa' graph\n# The size is determined based on the population data ('Pop2015') of each vertex\nV(g_africa)$size &lt;- 0.3*(V(g_africa)$Pop2015/40000)^0.5\n\nNow we are ready to plot the network, with a few extra modifications to the default plot in order to improve the appearance. As an exercise, you may want to try to plot the default visualisation by simply running plot(g_africa). If you do this, you will understand better why it is worth it spending some time playing with the values of the parameters in the plot function.\n\nplot(g_africa, vertex.size=V(g_africa)$size, edge.arrow.size=.15, edge.arrow.width=.2, edge.curved=0.1, edge.width=1, edge.color =\"gray90\",\nvertex.color=\"red\", vertex.frame.color=\"black\", vertex.frame.width=0.2,\nvertex.label=\" \", vertex.label.color=\"black\",\nvertex.label.cex=.65)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>The African road network</span>"
    ]
  },
  {
    "objectID": "percolation.html#analysing-network-resilience",
    "href": "percolation.html#analysing-network-resilience",
    "title": "4  Applications",
    "section": "4.3 Analysing network resilience",
    "text": "4.3 Analysing network resilience\nAnalysing network resilience through a percolation theory approach offers insights into how networks behave under failure or attack. Percolation theory was originally developed in statistical physics to study the behavior of connected clusters in a system as its elements are removed or fail. When applied to network analysis, it helps to quantify the threshold at which a network transitions from a well-connected state to one where large-scale connectivity is lost. This approach is particularly valuable in assessing the resilience of networks by determining their vulnerability to fragmentation and identifying critical points where network connectivity might collapse.\nTypically, a full percolation algorithm or process is run so that in each iteration, the value of a percolation parameter that controls the removal of nodes or edges is updated, and nodes or edges are removed accordingly. In each iteration, key resilience metrics are measured. One of the most used resilience metrics is the number of nodes in the largest connected component after the removal of nodes or edges. This metric is known as the size of the giant connected component (GCC). In many cases, we observe that for certain values of the percolation parameter, abrupt changes occur in the size of the GCC, showing that some sort of failure occurs in the network that qualitatively changes its connectivity structure.\nBelow we demonstrate this type of analysis. Our percolation parameter of choice is the time of travel through each edge taking into account the presence of borders. This variable is encoded by the timeUCB field in the df_edges data frame. In each iteration of the percolation process, edges with timeUCB above the value of the percolation parameter are removed from the network. Furthemore, instead of considering the whole African road network, we will work with a subset, as this will facilitate timely execution of the algorithm. Particularly, we will use a subset fomed by nodes and edges from the South region.\n\n# Subset the df_nodes data frame to include only rows where Region is \"South\"\ndf_nodes_sub &lt;- subset(df_nodes, Region == \"South\")\n\n# Subset df_edges to include only rows where 'from' column values are in df_nodes_sub$Agglomeration_ID\ndf_edges_sub &lt;- subset(df_edges, from %in% df_nodes_sub$Agglomeration_ID)\n\n# Subset df_edges_sub to include only rows where 'to' column values are in df_nodes_sub$Agglomeration_ID\ndf_edges_sub &lt;- subset(df_edges_sub, to %in% df_nodes_sub$Agglomeration_ID)\n\nWe can create an undirected graph from the redefined data frames of nodes and edges.\n\n# Create an igraph graph 'g_sub' from data frames 'df_edges_sub' and 'df_nodes_sub'\ng_sub &lt;- graph_from_data_frame(d = df_edges_sub,\n                           vertices = df_nodes_sub,\n                           directed = FALSE)\n\nWe can also visualise this subnetwork by running the code below. To give more geographical context to the above visualisation, we will add the outlines of the countries in the South region as a base layer for this plot. These are Botswana, Eswatini, Lesotho, Namibia, South Africa.\n\n# Define a vector of target countries\nsouth_countries &lt;- c(\"Botswana\", \"eSwatini\", \"Lesotho\", \"Namibia\", \"South Africa\")\n\n# Subset the world map data to include only the target countries\nworld_south &lt;- world[world$SOVEREIGNT %in% south_countries, ]\n\n# Specify node layout\ncustom_layout &lt;- data.frame(\n  name = df_nodes_sub$agglosName,  # Node names from the graph\n  x = df_nodes_sub$x ,    # Custom x-coordinates\n  y = df_nodes_sub$y )   # Custom y-coordinates\n\n\n# Create plot\nplot_sub &lt;- ggraph(as_tbl_graph(g_sub), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g_sub)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = \"red\", size = V(g_sub)$size)) + # custom nodes\n  scale_size_continuous(range = c(.1, 6)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_south , fill = NA, color = \"black\") # basic map plot\n\nWarning: Existing variables `name`, `x`, and `y` overwritten by layout\nvariables\n\nplot_sub\n\n\n\n\n\n\n\nFigure 4.2: Visualisation of road network in the South region of the African continent.\n\n\n\n\n\n\n4.3.1 The percolation algorithm\nWe start by creating some empty data structures where we will be storing information about the network and the percolation parameter in each iteration of our percolation algorithm. This will help us analyse the results later on. To do this we create four empty lists, where we will store the value of the percolation parameter in each iteration, the size of the GCC, the number of connected components and the average time to travel between any pair of nodes. By the end of the percolation process, these lists will contain \\(n_{iterations}\\) elements each.\n\n# Create empty vectors to store thresholds, gccs, ncs, and times\nthresholds &lt;- c()\ngccs &lt;- c()\nncs &lt;- c()\ntimes &lt;- c()\n\nWe are ready to perform the percolation algorithm. Each line of code has been commented to describe what the algorithm does at each step:\n\n# Iterate over thresholds\nfor (i in seq(0, max(df_edges_sub$timeUCB))) {\n\n  # Create modified data frames based on the current threshold\n  df_nodes_perco &lt;- df_nodes_sub\n  df_edges_perco &lt;- subset(df_edges_sub, timeUCB &lt; i)\n\n  # Create a graph g_perco from the modified data frames\n  g_perco &lt;- graph_from_data_frame(d = df_edges_perco,\n                         vertices = df_nodes_perco,\n                         directed = FALSE)\n\n  # Get connected components of the modified graph g_perco\n  connected_components &lt;- components(g_perco)\n\n  # Append the current threshold value to the 'thresholds' list\n  thresholds &lt;- c(thresholds, i)\n\n  # Append the maximum connected component size to the 'gccs' list\n  gccs &lt;- c(gccs, max(connected_components$csize))\n\n  # Append the number of connected components to the 'ncs' list\n  ncs &lt;- c(ncs, connected_components$no)\n\n  # Calculate and append the mean distance weighted by timeUCB in g_perco to 'times' list\n  times &lt;- c(times, mean_distance(g_perco, directed=FALSE, weights=df_edges_perco$timeUCB, unconnected=TRUE))\n}\n\n\n\n4.3.2 Changes in the size of the giant connected component as edges are removed\nOnce the algorithm is done running, we can plot the size of the GCC as the value of the percolation parameter is varied.\n\n# Create a data frame for the plot with thresholds and gccs\ndf &lt;- data.frame(x = thresholds, y = gccs)\n\n\n#|\n# Create a ggplot2 plot\nggplot(data = df, aes(x = x, y = y)) +\n  geom_line(color = \"blue\") +\n  labs(x = \"Travel time with border effect (minutes)\", y = \"Size of GCC\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 4.3: Relationship between the size of the Giant Connected Component and the percolation parameter.\n\n\n\n\n\nWe observe that for small values of the percolation parameter rapid changes occur in the size of the GCC. When the percolation parameter takes approximately the values 150, 650, 1000, there are sudden changes in the size of the GCC, showing that there has been a significant alteration in the network’s topology. For example, when edges with associated travel times above 1000 minutes are removed, nodes that act like hubs may lose connections and as a result, the GCC may experience a significant drop in size.\n\n\n4.3.3 Changes in the number of connected components as edges are removed\nWe can also plot the number of connected components as the value of the percolation parameter is varied.\n\n# Create a data frame for the plot with thresholds and ncs\ndf &lt;- data.frame(x = thresholds, y = ncs)\n\n\n#|\n# Create a ggplot2 plot\nggplot(data = df, aes(x = x, y = y)) +\n  geom_line(color = \"blue\") +\n  labs(x = \"Travel time with border effect (minutes)\", y = \"No. of connected components\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 4.4: Relationship between the number of connected components and the percolation parameter.\n\n\n\n\n\nWe observe that for small values of the percolation threshold, nearly all the edges in the network are removed, so there are as many components as there are nodes. We also see that if we increase the percolation threshold above 250 minutes, the number of connected components is reduced, showing that the connectivity of the network is restored as we add additional edges.\n\n\n4.3.4 Changes in the average travel time as edges are removed\nFinally, we plot the average travel time between any pair of nodes as the value of the percolation parameter is varied.\n\n# Create a data frame for the plot with thresholds and times\ndf &lt;- data.frame(x = thresholds, y = times)\n\n\n# Create a ggplot2 plot\nggplot(data = df, aes(x = x, y = y)) +\n  geom_line(color = \"blue\") +\n  labs(x = \"Travel time with border effect (minutes)\", y = \"Average travel time (minutes)\") +\n  theme_minimal()\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\nFigure 4.5: Relationship between the average travel time with border effect (minutes) and the percolation parameter.\n\n\n\n\n\nNote that when the percolation parameter is 0, all the edges are removed, so the corresponding value of the average travel time is NA. As we increase the percolation parameter, edges are added and more possible paths arise in the network. Note that the average travel time is only computed for existing paths (hence the unconnected=TRUE parameter in the mean_distance() function). The sudden changes in the average travel time and the sudden changes in the size of the GCC happen for the same values of the percolation parameter. For example, when the percolation parameter is approximately equal to 650 minutes, we see a large increase in the average travel time. This suggests that two parts of the network that were unconnected for lower values of the percolation parameter, become connected for values above 650 minutes approximately and as a result, the average travel time increases since there are possibilities to travel further.\n\n\n\n\n\n\nNote\n\n\n\nCan you think of other possible applications of percolation theory in the context of geographical netowrks?\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can check an application of network theory to detect the sensitive spots of the African interurban transport network in (Renninger et al. 2023).\n\n\n\n\n\n\n\nBlondel, Vincent D, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefebvre. 2008. “Fast Unfolding of Communities in Large Networks.” Journal of Statistical Mechanics: Theory and Experiment 2008 (10): P10008. https://doi.org/10.1088/1742-5468/2008/10/p10008.\n\n\nFortunato, Santo, and Mark E. J. Newman. 2022. “20 Years of Network Community Detection.” Nature Physics 18 (8): 848–50. https://doi.org/10.1038/s41567-022-01716-7.\n\n\nGirvan, M., and M. E. J. Newman. 2002. “Community Structure in Social and Biological Networks.” Proceedings of the National Academy of Sciences 99 (12): 7821–26. https://doi.org/10.1073/pnas.122653799.\n\n\nPons, Pascal, and Matthieu Latapy. 2005. “Computing Communities in Large Networks Using Random Walks.” In, 284–93. Springer Berlin Heidelberg. https://doi.org/10.1007/11569596_31.\n\n\nRenninger, Andrew, Valentina Marín Maureira, Carmen Cabrera-Arnau, and Rafael Prieto-Curiel. 2023. “Detecting the Sensitive Spots of the African Interurban Transport Network.” https://arxiv.org/abs/2307.06402.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "come-prepared.html",
    "href": "come-prepared.html",
    "title": "1  Come prepared",
    "section": "",
    "text": "2 Prerequisites\n\n\n\n\n\n\nImportant\n\n\n\nPlease make sure you download and install the most recent version of R, RStudio and Quarto on the computer that you will be using during the workshop, and install the indicated R packages – see detailed instructions below.\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll three software packages are open and free to use.\n\n\nR\nYou can download R here. Make sure you select the appropriate version for your Operating System: Windows, MacOS (Apple silicon M1/M2 or older intel Macs). For example, if you use a macOS laptop with an M1 processor, click on ‘Download R for macOS’ and then, click the link to download the installer file (.pkg extension for macOS) under the header ‘For Apple silicon (M1/M2) Macs’. You can then open the installer and follow the instructions that you will be prompted with. For Windows users, click on ‘install R for the first time’ and follow the prompts.\nRStudio\nYou will also need to download RStudio Desktop (or simply RStudio), which is an integrated development environment to help you write code in R more easily. To download RStudio, follow this link and scroll down to the section titled ‘All Installers and Tarballs’. Download the appropriate installer file according to your Operating System. Then, open the installer and follow the installation instructions that you will be prompted with.\nQuarto\nDownload Quarto from this website. Quarto is a publishing system that will allow you to open and work on the computational notebooks for the workshop. On ‘Step 1’ on the website, download the version of Quarto that matches your Operating System. Open the installer file, run it and follow the prompts.\nR packages\nOnce you have installed R, you will need to install some R extensions, known as packages, that will be useful for the applications explored in this workshop. In this case, you only need to install one package:\n\nigraph\nsf\ntidyverse\nggplot2\nggraph\npatchwork\ntidygraph\nRColorBrewer\nrnaturalearth\n\nTo install any package, open RStudio. On the console window (normally at the bottom left), write the following command: install.packages(\"name of package\"). Make sure you replace “name of package” by the actual name of the package that you want to install e.g. install.packages(\"tidyverse\"). Then, press enter and repeat this process until you have installed all the packages in the list.\nIf there are several packages you need to install, you can also install them all at once by copying and running the code below:\n\nlist.of.packages.cran &lt;- c(\n   \"igraph\", \n   \"sf\",\n   \"tidyverse\",\n   \"ggplot2\",\n   \"ggraph\",\n   \"patchwork\",\n   \"tidygraph\",\n   \"RColorBrewer\",\n   \"rnaturalearth\"\n)\n\nnew.packages.cran &lt;- list.of.packages.cran[!(list.of.packages.cran %in% installed.packages()[,\"Package\"])]\nif(length(new.packages.cran)) install.packages(new.packages.cran)\n\nfor(i in 1:length(list.of.packages.cran)) {\n  library(list.of.packages.cran[i], character.only = T)\n}\n\nOnce your packages are installed, you will need to load them in order to be able to use it in your code. This can be done by copying and running the code below:\n\ndeps &lt;- list(\n   \"igraph\", \n   \"sf\",\n   \"tidyverse\",\n   \"ggplot2\",\n   \"ggraph\",\n   \"patchwork\",\n   \"tidygraph\",\n   \"RColorBrewer\",\n   \"rnaturalearth\"\n)\n\nfor(lib in deps){library(lib, character.only = TRUE)}\n\nOr you can load them one by one simply running, for example, library(igraph) for igraph.\n\n\n\n\n\n\nImportant\n\n\n\nFurther instructions on how to download the workshop material from Github will be given during the workshop."
  },
  {
    "objectID": "prerequisites.html",
    "href": "prerequisites.html",
    "title": "1  Prerequisites",
    "section": "",
    "text": "Important\n\n\n\nPlease make sure you download and install the most recent version of R, RStudio and Quarto on the computer that you will be using during the workshop, and install the indicated R packages – see detailed instructions below.\n\n\n\n\n\n\n\n\nNote\n\n\n\nAll three software packages are open and free to use.\n\n\nR\nYou can download R here. Make sure you select the appropriate version for your Operating System: Windows, MacOS (Apple silicon M1/M2 or older intel Macs). For example, if you use a macOS laptop with an M1 processor, click on ‘Download R for macOS’ and then, click the link to download the installer file (.pkg extension for macOS) under the header ‘For Apple silicon (M1/M2) Macs’. You can then open the installer and follow the instructions that you will be prompted with. For Windows users, click on ‘install R for the first time’ and follow the prompts.\nRStudio\nYou will also need to download RStudio Desktop (or simply RStudio), which is an integrated development environment to help you write code in R more easily. To download RStudio, follow this link and scroll down to the section titled ‘All Installers and Tarballs’. Download the appropriate installer file according to your Operating System. Then, open the installer and follow the installation instructions that you will be prompted with.\nQuarto\nDownload Quarto from this website. Quarto is a publishing system that will allow you to open and work on the computational notebooks for the workshop. On ‘Step 1’ on the website, download the version of Quarto that matches your Operating System. Open the installer file, run it and follow the prompts.\nR packages\nOnce you have installed R, you will need to install some R extensions, known as packages, that will be useful for the applications explored in this workshop. In this case, you only need to install one package:\n\nigraph\nsf\ntidyverse\nggplot2\nggraph\npatchwork\ntidygraph\nRColorBrewer\nrnaturalearth\n\nTo install any package, open RStudio. On the console window (normally at the bottom left), write the following command: install.packages(\"name of package\"). Make sure you replace “name of package” by the actual name of the package that you want to install e.g. install.packages(\"tidyverse\"). Then, press enter and repeat this process until you have installed all the packages in the list.\nIf there are several packages you need to install, you can also install them all at once by copying and running the code below:\n\nlist.of.packages.cran &lt;- c(\n   \"igraph\", \n   \"sf\",\n   \"tidyverse\",\n   \"ggplot2\",\n   \"ggraph\",\n   \"patchwork\",\n   \"tidygraph\",\n   \"RColorBrewer\",\n   \"rnaturalearth\"\n)\n\nnew.packages.cran &lt;- list.of.packages.cran[!(list.of.packages.cran %in% installed.packages()[,\"Package\"])]\nif(length(new.packages.cran)) install.packages(new.packages.cran)\n\nfor(i in 1:length(list.of.packages.cran)) {\n  library(list.of.packages.cran[i], character.only = T)\n}\n\nOnce your packages are installed, you will need to load them in order to be able to use it in your code. This can be done by copying and running the code below:\n\ndeps &lt;- list(\n   \"igraph\", \n   \"sf\",\n   \"tidyverse\",\n   \"ggplot2\",\n   \"ggraph\",\n   \"patchwork\",\n   \"tidygraph\",\n   \"RColorBrewer\",\n   \"rnaturalearth\"\n)\n\nfor(lib in deps){library(lib, character.only = TRUE)}\n\nOr you can load them one by one simply running, for example, library(igraph) for igraph.\n\n\n\n\n\n\nImportant\n\n\n\nFurther instructions on how to download the workshop material from Github will be given during the workshop.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Prerequisites</span>"
    ]
  },
  {
    "objectID": "percolation.html",
    "href": "percolation.html",
    "title": "4  Applications",
    "section": "",
    "text": "4.1 Dependencies\nWe first clean the environment and load all the libraries required for this section.\n# Load required packages\nlibrary(igraph)    # for network analysis\nlibrary(ggplot2)   # for data visualization\nlibrary(ggraph)    # for graph visualization\nlibrary(patchwork) # for arranging plots\nlibrary(tidygraph) # for tidy data handling with graphs\nlibrary(RColorBrewer) # for color palettes\nlibrary(rnaturalearth) # for natural earth map data\nlibrary(sf)        # for spatial data manipulation\nLike before, we define the network of African roads from dataframes containing nodes and edges data. The dataframes can be found at https://github.com/CrmnCA/nets4gis within the data folder.\n# Read the CSV file containing network nodes data\ndf_nodes &lt;- read.csv(\"./data/AfricaNetworkNodes.csv\")\n\n# Read the CSV file containing network edges data\ndf_edges &lt;- read.csv(\"./data/AfricaNetworkEdges.csv\")\n\n# Create a network called 'g' from data frames 'df_edges' and 'df_nodes'\n# Make the netwrok is undirected (directed = FALSE)\ng &lt;- graph_from_data_frame(d = df_edges,\n                                       vertices = df_nodes,\n                                       directed = FALSE)\nFor visualisations, we will load the shapes of the African countries as a spatial feature object, with the ne_download function. This will be used as a basemap\n# Download world map data with specified parameters\nworld &lt;- ne_download(scale = \"small\", category = \"cultural\", type = \"admin_0_countries\", returnclass = \"sf\")\n\nReading layer `ne_110m_admin_0_countries' from data source \n  `/private/var/folders/79/65l52xsj7vq_4_t_l6k5bl2c0000gn/T/RtmpWSgY3a/ne_110m_admin_0_countries.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 177 features and 168 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -180 ymin: -90 xmax: 180 ymax: 83.64513\nGeodetic CRS:  WGS 84\n\n# Define a vector of target countries\ntarget_countries &lt;- c(\"DZA\", \"AGO\", \"BEN\", \"BWA\", \"BFA\", \"BDI\", \"CMR\", \"CPV\", \"CAF\", \"TCD\", \"COM\", \"COG\", \"COD\", \"CIV\", \"DJI\", \"EGY\", \"GNQ\", \"ERI\", \"ETH\", \"GAB\", \"GMB\", \"GHA\", \"GIN\", \"GNB\", \"KEN\", \"LSO\", \"LBR\", \"LBY\", \"MDG\", \"MLI\", \"MWI\", \"MRT\", \"MUS\", \"MYT\", \"MAR\", \"MOZ\", \"NAM\", \"NER\", \"NGA\", \"REU\", \"RWA\", \"STP\", \"SEN\", \"SYC\", \"SLE\", \"SOM\", \"ZAF\", \"SSD\", \"SDN\", \"SWZ\", \"TZA\", \"TGO\", \"TUN\", \"UGA\", \"ESH\", \"ZMB\", \"ZWE\")\n\n# Subset the world map data to include only the target countries\nworld_subset &lt;- world[world$SOV_A3 %in% target_countries, ]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#walktrap",
    "href": "percolation.html#walktrap",
    "title": "4  Applications",
    "section": "5.1 Walktrap",
    "text": "5.1 Walktrap\nThis algorithm relies on the concept of random walks on networks. Random walks are sequences of nodes, chosen by following a randomly chosen path. The underlying assumption of the walktrap method is that nodes encountered in a given random walk are more likely to be part of the same community.\nThe algorithm starts by treating each node as its own community. Then, it performs a series of short random walks on the network, where the length of these walks has to be specified by the user. After performing the random walks, the algorithm calculates a similarity measure between each pair of nodes. This measure is based on the idea that if two nodes are often encountered together during random walks, they are likely part of the same community. Nodes that have high similarity are merged into larger communities. This merging process is hierarchical and agglomerative, starting with individual nodes and progressively combining them. As communities are merged, the algorithm often aims to maximise a measure called modularity, which quantifies the strength of the division of the network into communities. High modularity indicates a good community structure, where more edges fall within communities than between communities. The process continues until the entire network is merged into a single community or until a stopping criterion, like a modularity threshold, is met. Depending on the implementation, the algorithm may return a hierarchical structure of communities, allowing the user to explore different levels of granularity in the community structure.\nIn R, the walktrap method is implemented via the igraph function cluster_walktrap(), with key parameters including the network of interest as an igraph object, the length of the random walks, and a membership parameter, which is a boolean variable indicating whether to calculate membership based on the highest modularity score, with True as the default. Below, we apply the walktrap method to the African road network and save the result in the variable g_wt:\n\ng_wt &lt;- cluster_walktrap(graph = g, steps = 3, membership = T)\n\nWe can get the membership of each node as well the modularity score according to the solution based on random walks of length 3. We save the results with the name member_g_wt and mod_g_wt:\n\nmember_g_wt &lt;- membership(g_wt)\nmodularity_g_wt &lt;- modularity(g_wt)\n\nWe can plot the network based on the found communities. We will plot the network as before, but color the nodes based on the communities found using the walktrap algorithm.\n\ncustom_layout &lt;- data.frame(\n  name = df_nodes$agglosName,  # Node names from the graph\n  x = df_nodes$x ,    # Custom x-coordinates\n  y = df_nodes$y )   # Custom y-coordinates\n\nplot_wt &lt;- ggraph(as_tbl_graph(g), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = member_g_wt, size = V(g)$size)) + # custom nodes\n  scale_size_continuous(range = c(.3, 4)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_subset, fill = NA, color = \"black\") + # basic map plot\n  ggtitle(\"Walktrap method\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#edge-betweenness-community-detection",
    "href": "percolation.html#edge-betweenness-community-detection",
    "title": "4  Applications",
    "section": "5.2 Edge betweenness community detection",
    "text": "5.2 Edge betweenness community detection\nThe edge-betweenness community detection method identifies communities within a network by focusing on the edges that connect different communities. It works by progressively removing edges that act as bridges between groups of nodes, from higher to lower betweenness centrality. As high-betweenness edges are removed, the network breaks down into smaller, more cohesive subgroups or communities. This method is particularly useful for finding natural divisions within a network, though it can be computationally intensive for large networks.\nThe algorithm starts by computing the betweenness centrality for all edges in the network. Edges with high betweenness are likely to be those that connect different communities. Then, the edge with the highest betweenness centrality is removed from the network. This step effectively “cuts” the bridge between communities. After removing the edge, the betweenness centrality for the remaining edges is recomputed since the removal of one edge may change the shortest paths in the network, affecting the betweenness centrality of other edges. Edges with the highest betweenness centrality keep being removed until all edges have been removed or until the network breaks down into the desired number of communities.\nIn R, the edge betweenness community detection method is implemented via the igraph function cluster_edge_betweenness(). The key parameters are the network of interest as an igraph object and a membership parameter, a boolean variable indicating whether to calculate membership based on the highest modularity score, with True as the default. Below, we apply the edge betweenness method to the African road network and save the result in the variable g_eb:\n\ng_eb &lt;- cluster_edge_betweenness(graph = g, membership = T)\n\nOnce again, we can get the membership of each node according to the solution based on edge betweenness. We save the results with the name member_g_eb:\n\nmember_g_eb &lt;- membership(g_eb)\n\nThen, we generate a plot of the results. We include the plot in Figure Figure 5.1.\n\nplot_eb &lt;- ggraph(as_tbl_graph(g), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = member_g_eb, size = V(g)$size)) + # custom nodes\n  scale_size_continuous(range = c(.3, 4)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_subset, fill = NA, color = \"black\") + # basic map plot\n  ggtitle(\"Edge betweenness\\n clustering\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#louvain-method",
    "href": "percolation.html#louvain-method",
    "title": "4  Applications",
    "section": "5.3 Louvain method",
    "text": "5.3 Louvain method\nThe Louvain method of multi-level clustering works by finding communities in such a way that the modularity of the network is maximised. The algorithm works in two phases: first, each node starts in its own community, and nodes are iteratively moved to neighboring communities if the move increases modularity. This phase continues until no further improvement is possible. In the second phase, the network is compressed by treating each community found in the first phase as a single node, creating a new, smaller network. The two phases are then repeated on this simplified network, refining the community structure at each level. The process continues until modularity no longer increases, resulting in a hierarchical clustering that reflects the community structure within the network.\nOn R, the Louvain method is implemented via the cluster_louvain function, where the arguments are the graph and the resolution. Higher resolution values will yield a larger number of smaller communities, while lower values will yield a smaller number of larger communities.\n\ng_mlc &lt;- cluster_louvain(graph = g, resolution = 1)\n\nWe get the membership of each node according to the communities found by the Louvain’s multi-level clustering method. The results are saved with the name member_g_mlc:\n\nmember_g_mlc &lt;- membership(g_mlc)\n\nWe can then generate a plot of the results:\n\nplot_mlc &lt;- ggraph(as_tbl_graph(g), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = member_g_mlc, size = V(g)$size)) + # custom nodes\n  scale_size_continuous(range = c(.3, 4)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_subset, fill = NA, color = \"black\") + # basic map plot\n  ggtitle(\"Louvain method\")\n\nIn Figure Figure 5.1, we visualise the results of the three community detection methods, i.e. walktrap, edge betweenness and the Louvain method. The results reflect the fact that nodes that are geographically close and are part of densely connected clusters, generally belong to the same community, regardless of the method used. There is some degree of correspondance between the detected communities and the African countries.\n\nplot_wt + plot_eb + plot_mlc\n\n\n\n\n\n\n\nFigure 5.1: Results of three community detection algorithms: walktrap, edge betweenness and multi-level clustering or Louvain.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#the-percolation-algorithm",
    "href": "percolation.html#the-percolation-algorithm",
    "title": "4  Applications",
    "section": "6.1 The percolation algorithm",
    "text": "6.1 The percolation algorithm\nWe start by creating some empty data structures where we will be storing information about the network and the percolation parameter in each iteration of our percolation algorithm. This will help us analyse the results later on. To do this we create four empty lists, where we will store the value of the percolation parameter in each iteration, the size of the GCC, the number of connected components and the average time to travel between any pair of nodes. By the end of the percolation process, these lists will contain \\(n_{iterations}\\) elements each.\n\n# Create empty vectors to store thresholds, gccs, ncs, and times\nthresholds &lt;- c()\ngccs &lt;- c()\nncs &lt;- c()\ntimes &lt;- c()\n\nWe are ready to perform the percolation algorithm. Each line of code has been commented to describe what the algorithm does at each step:\n\n# Iterate over thresholds\nfor (i in seq(0, max(df_edges_sub$timeUCB))) {\n\n  # Create modified data frames based on the current threshold\n  df_nodes_perco &lt;- df_nodes_sub\n  df_edges_perco &lt;- subset(df_edges_sub, timeUCB &lt; i)\n\n  # Create a graph g_perco from the modified data frames\n  g_perco &lt;- graph_from_data_frame(d = df_edges_perco,\n                         vertices = df_nodes_perco,\n                         directed = FALSE)\n\n  # Get connected components of the modified graph g_perco\n  connected_components &lt;- components(g_perco)\n\n  # Append the current threshold value to the 'thresholds' list\n  thresholds &lt;- c(thresholds, i)\n\n  # Append the maximum connected component size to the 'gccs' list\n  gccs &lt;- c(gccs, max(connected_components$csize))\n\n  # Append the number of connected components to the 'ncs' list\n  ncs &lt;- c(ncs, connected_components$no)\n\n  # Calculate and append the mean distance weighted by timeUCB in g_perco to 'times' list\n  times &lt;- c(times, mean_distance(g_perco, directed=FALSE, weights=df_edges_perco$timeUCB, unconnected=TRUE))\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#changes-in-the-size-of-the-giant-connected-component-as-edges-are-removed",
    "href": "percolation.html#changes-in-the-size-of-the-giant-connected-component-as-edges-are-removed",
    "title": "4  Applications",
    "section": "6.2 Changes in the size of the giant connected component as edges are removed",
    "text": "6.2 Changes in the size of the giant connected component as edges are removed\nOnce the algorithm is done running, we can plot the size of the GCC as the value of the percolation parameter is varied.\n\n# Create a data frame for the plot with thresholds and gccs\ndf &lt;- data.frame(x = thresholds, y = gccs)\n\n\n#|\n# Create a ggplot2 plot\nggplot(data = df, aes(x = x, y = y)) +\n  geom_line(color = \"blue\") +\n  labs(x = \"Travel time with border effect (minutes)\", y = \"Size of GCC\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 6.2: Relationship between the size of the Giant Connected Component and the percolation parameter.\n\n\n\n\n\nWe observe that for small values of the percolation parameter rapid changes occur in the size of the GCC. When the percolation parameter takes approximately the values 150, 650, 1000, there are sudden changes in the size of the GCC, showing that there has been a significant alteration in the network’s topology. For example, when edges with associated travel times above 1000 minutes are removed, nodes that act like hubs may lose connections and as a result, the GCC may experience a significant drop in size.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#changes-in-the-number-of-connected-components-as-edges-are-removed",
    "href": "percolation.html#changes-in-the-number-of-connected-components-as-edges-are-removed",
    "title": "4  Applications",
    "section": "6.3 Changes in the number of connected components as edges are removed",
    "text": "6.3 Changes in the number of connected components as edges are removed\nWe can also plot the number of connected components as the value of the percolation parameter is varied.\n\n# Create a data frame for the plot with thresholds and ncs\ndf &lt;- data.frame(x = thresholds, y = ncs)\n\n\n#|\n# Create a ggplot2 plot\nggplot(data = df, aes(x = x, y = y)) +\n  geom_line(color = \"blue\") +\n  labs(x = \"Travel time with border effect (minutes)\", y = \"No. of connected components\") +\n  theme_minimal()\n\n\n\n\n\n\n\nFigure 6.3: Relationship between the number of connected components and the percolation parameter.\n\n\n\n\n\nWe observe that for small values of the percolation threshold, nearly all the edges in the network are removed, so there are as many components as there are nodes. We also see that if we increase the percolation threshold above 250 minutes, the number of connected components is reduced, showing that the connectivity of the network is restored as we add additional edges.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "percolation.html#changes-in-the-average-travel-time-as-edges-are-removed",
    "href": "percolation.html#changes-in-the-average-travel-time-as-edges-are-removed",
    "title": "4  Applications",
    "section": "6.4 Changes in the average travel time as edges are removed",
    "text": "6.4 Changes in the average travel time as edges are removed\nFinally, we plot the average travel time between any pair of nodes as the value of the percolation parameter is varied.\n\n# Create a data frame for the plot with thresholds and times\ndf &lt;- data.frame(x = thresholds, y = times)\n\n\n# Create a ggplot2 plot\nggplot(data = df, aes(x = x, y = y)) +\n  geom_line(color = \"blue\") +\n  labs(x = \"Travel time with border effect (minutes)\", y = \"Average travel time (minutes)\") +\n  theme_minimal()\n\nWarning: Removed 1 row containing missing values or values outside the scale range\n(`geom_line()`).\n\n\n\n\n\n\n\n\nFigure 6.4: Relationship between the average travel time with border effect (minutes) and the percolation parameter.\n\n\n\n\n\nNote that when the percolation parameter is 0, all the edges are removed, so the corresponding value of the average travel time is NA. As we increase the percolation parameter, edges are added and more possible paths arise in the network. Note that the average travel time is only computed for existing paths (hence the unconnected=TRUE parameter in the mean_distance() function). The sudden changes in the average travel time and the sudden changes in the size of the GCC happen for the same values of the percolation parameter. For example, when the percolation parameter is approximately equal to 650 minutes, we see a large increase in the average travel time. This suggests that two parts of the network that were unconnected for lower values of the percolation parameter, become connected for values above 650 minutes approximately and as a result, the average travel time increases since there are possibilities to travel further.\n\n\n\n\n\n\nNote\n\n\n\nCan you think of other possible applications of percolation theory in the context of geographical netowrks?\n\n\n\n\n\n\n\n\nNote\n\n\n\nYou can check an application of network theory to detect the sensitive spots of the African interurban transport network in (Renninger et al. 2023).\n\n\n\n\n\n\n\nBlondel, Vincent D, Jean-Loup Guillaume, Renaud Lambiotte, and Etienne Lefebvre. 2008. “Fast Unfolding of Communities in Large Networks.” Journal of Statistical Mechanics: Theory and Experiment 2008 (10): P10008. https://doi.org/10.1088/1742-5468/2008/10/p10008.\n\n\nFortunato, Santo, and Mark E. J. Newman. 2022. “20 Years of Network Community Detection.” Nature Physics 18 (8): 848–50. https://doi.org/10.1038/s41567-022-01716-7.\n\n\nGirvan, M., and M. E. J. Newman. 2002. “Community Structure in Social and Biological Networks.” Proceedings of the National Academy of Sciences 99 (12): 7821–26. https://doi.org/10.1073/pnas.122653799.\n\n\nPons, Pascal, and Matthieu Latapy. 2005. “Computing Communities in Large Networks Using Random Walks.” In, 284–93. Springer Berlin Heidelberg. https://doi.org/10.1007/11569596_31.\n\n\nRenninger, Andrew, Valentina Marín Maureira, Carmen Cabrera-Arnau, and Rafael Prieto-Curiel. 2023. “Detecting the Sensitive Spots of the African Interurban Transport Network.” https://arxiv.org/abs/2307.06402.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  },
  {
    "objectID": "introduction-networks.html",
    "href": "introduction-networks.html",
    "title": "2  Introduction to the basics of network analysis",
    "section": "",
    "text": "2.1 Dependencies\nWe first clean the environment and load all the libraries required for this section.\n# working with spatial data\nlibrary(sf)\n# data manipulation and visualisation\nlibrary(tidyverse)\n# network manipulation and analysis\nlibrary(igraph)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Introduction to the basics of network analysis</span>"
    ]
  },
  {
    "objectID": "african-network.html",
    "href": "african-network.html",
    "title": "3  The African road network",
    "section": "",
    "text": "3.1 Dependencies\nWe first clean the environment and load all the libraries required for this section.\n# An R package for network manipulation and analysis\nlibrary(igraph)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>The African road network</span>"
    ]
  },
  {
    "objectID": "percolation.html#community-detection",
    "href": "percolation.html#community-detection",
    "title": "4  Applications",
    "section": "4.2 Community detection",
    "text": "4.2 Community detection\nA network displays community structure if the nodes can be grouped into sets such that the nodes within each set are densely connected. For example, in the case of a social network formed by the students in a classroom, we would expect that small groups of friends form within the overall network, where relationships among members of a group are stronger than to everyone else in the classroom. Detecting or searching communities within in a network is a fundamental problem in network analysis, which has attracted much attention in the past decades (Fortunato and Newman 2022). While there are different methods to detect communities, below we review four of them which have been widely used and studied. These are walktrap (Pons and Latapy 2005), edge-betweenness (Girvan and Newman 2002) and hierarchical clustering (Blondel et al. 2008). Each method defines communities differently, and the choice of method depends on which aspect of communities is emphasised in a particular application.\n\n4.2.1 Walktrap\nThis algorithm relies on the concept of random walks on networks. Random walks are sequences of nodes, chosen by following a randomly chosen path. The underlying assumption of the walktrap method is that nodes encountered in a given random walk are more likely to be part of the same community.\nThe algorithm starts by treating each node as its own community. Then, it performs a series of short random walks on the network, where the length of these walks has to be specified by the user. After performing the random walks, the algorithm calculates a similarity measure between each pair of nodes. This measure is based on the idea that if two nodes are often encountered together during random walks, they are likely part of the same community. Nodes that have high similarity are merged into larger communities. This merging process is hierarchical and agglomerative, starting with individual nodes and progressively combining them. As communities are merged, the algorithm often aims to maximise a measure called modularity, which quantifies the strength of the division of the network into communities. High modularity indicates a good community structure, where more edges fall within communities than between communities. The process continues until the entire network is merged into a single community or until a stopping criterion, like a modularity threshold, is met. Depending on the implementation, the algorithm may return a hierarchical structure of communities, allowing the user to explore different levels of granularity in the community structure.\nIn R, the walktrap method is implemented via the igraph function cluster_walktrap(), with key parameters including the network of interest as an igraph object, the length of the random walks, and a membership parameter, which is a boolean variable indicating whether to calculate membership based on the highest modularity score, with True as the default. Below, we apply the walktrap method to the African road network and save the result in the variable g_wt:\n\ng_wt &lt;- cluster_walktrap(graph = g, steps = 3, membership = T)\n\nWe can get the membership of each node as well the modularity score according to the solution based on random walks of length 3. We save the results with the name member_g_wt and mod_g_wt:\n\nmember_g_wt &lt;- membership(g_wt)\nmodularity_g_wt &lt;- modularity(g_wt)\n\nWe can plot the network based on the found communities. We will plot the network as before, but color the nodes based on the communities found using the walktrap algorithm.\n\ncustom_layout &lt;- data.frame(\n  name = df_nodes$agglosName,  # Node names from the graph\n  x = df_nodes$x ,    # Custom x-coordinates\n  y = df_nodes$y )   # Custom y-coordinates\n\nplot_wt &lt;- ggraph(as_tbl_graph(g), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = member_g_wt, size = V(g)$size)) + # custom nodes\n  scale_size_continuous(range = c(.3, 4)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_subset, fill = NA, color = \"black\") + # basic map plot\n  ggtitle(\"Walktrap method\")\n\n\n\n4.2.2 Edge betweenness community detection\nThe edge-betweenness community detection method identifies communities within a network by focusing on the edges that connect different communities. It works by progressively removing edges that act as bridges between groups of nodes, from higher to lower betweenness centrality. As high-betweenness edges are removed, the network breaks down into smaller, more cohesive subgroups or communities. This method is particularly useful for finding natural divisions within a network, though it can be computationally intensive for large networks.\nThe algorithm starts by computing the betweenness centrality for all edges in the network. Edges with high betweenness are likely to be those that connect different communities. Then, the edge with the highest betweenness centrality is removed from the network. This step effectively “cuts” the bridge between communities. After removing the edge, the betweenness centrality for the remaining edges is recomputed since the removal of one edge may change the shortest paths in the network, affecting the betweenness centrality of other edges. Edges with the highest betweenness centrality keep being removed until all edges have been removed or until the network breaks down into the desired number of communities.\nIn R, the edge betweenness community detection method is implemented via the igraph function cluster_edge_betweenness(). The key parameters are the network of interest as an igraph object and a membership parameter, a boolean variable indicating whether to calculate membership based on the highest modularity score, with True as the default. Below, we apply the edge betweenness method to the African road network and save the result in the variable g_eb:\n\ng_eb &lt;- cluster_edge_betweenness(graph = g, membership = T)\n\nOnce again, we can get the membership of each node according to the solution based on edge betweenness. We save the results with the name member_g_eb:\n\nmember_g_eb &lt;- membership(g_eb)\n\nThen, we generate a plot of the results. We include the plot in Figure Figure 4.1.\n\nplot_eb &lt;- ggraph(as_tbl_graph(g), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = member_g_eb, size = V(g)$size)) + # custom nodes\n  scale_size_continuous(range = c(.3, 4)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_subset, fill = NA, color = \"black\") + # basic map plot\n  ggtitle(\"Edge betweenness\\n clustering\")\n\n\n\n4.2.3 Louvain method\nThe Louvain method of multi-level clustering works by finding communities in such a way that the modularity of the network is maximised. The algorithm works in two phases: first, each node starts in its own community, and nodes are iteratively moved to neighboring communities if the move increases modularity. This phase continues until no further improvement is possible. In the second phase, the network is compressed by treating each community found in the first phase as a single node, creating a new, smaller network. The two phases are then repeated on this simplified network, refining the community structure at each level. The process continues until modularity no longer increases, resulting in a hierarchical clustering that reflects the community structure within the network.\nOn R, the Louvain method is implemented via the cluster_louvain function, where the arguments are the graph and the resolution. Higher resolution values will yield a larger number of smaller communities, while lower values will yield a smaller number of larger communities.\n\ng_mlc &lt;- cluster_louvain(graph = g, resolution = 1)\n\nWe get the membership of each node according to the communities found by the Louvain’s multi-level clustering method. The results are saved with the name member_g_mlc:\n\nmember_g_mlc &lt;- membership(g_mlc)\n\nWe can then generate a plot of the results:\n\nplot_mlc &lt;- ggraph(as_tbl_graph(g), custom_layout) + # basic graph plot with custom layout\n  geom_edge_link(color = \"gray80\", alpha=0.9, aes(width = E(g)$l*0.1)) + # custom edges\n  scale_edge_width(range = c(.1, 0.7)) + # scale edge size\n  geom_node_point(aes(color = member_g_mlc, size = V(g)$size)) + # custom nodes\n  scale_size_continuous(range = c(.3, 4)) + # scale node size\n  scale_color_identity() + # scale node color (not relevant for this plot, but could be for others)\n  theme(legend.position = \"none\", panel.background=element_rect(fill = NA, colour = NA)) + # map legend and background color\n  geom_sf(data = world_subset, fill = NA, color = \"black\") + # basic map plot\n  ggtitle(\"Louvain method\")\n\nIn Figure Figure 4.1, we visualise the results of the three community detection methods, i.e. walktrap, edge betweenness and the Louvain method. The results reflect the fact that nodes that are geographically close and are part of densely connected clusters, generally belong to the same community, regardless of the method used. There is some degree of correspondance between the detected communities and the African countries.\n\nplot_wt + plot_eb + plot_mlc\n\n\n\n\n\n\n\nFigure 4.1: Results of three community detection algorithms: walktrap, edge betweenness and multi-level clustering or Louvain.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Applications</span>"
    ]
  }
]