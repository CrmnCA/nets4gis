# Percolation theory

```{r}
# Load required packages
library(igraph)    # for network analysis
library(sf)        # for spatial data handling
library(ggplot2)   # for plotting
library(leaflet)   # for interactive maps

```

## Introduction

## Uncovering the hierarchical structure of the African road network

```{r}
# Read edge and node data from URLs
df_edges <- read.csv("https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkEdges.csv")
df_nodes <- read.csv("https://raw.githubusercontent.com/rafaelprietocuriel/AfricanUrbanNetwork/main/AfricaNetworkNodes.csv", encoding='UTF-8')
```

```{r}
df_nodes <- subset(df_nodes, Region == "South")
```

```{r}
df_edges <- subset(df_edges, from %in% df_nodes$Agglomeration_ID)
df_edges <- subset(df_edges, to %in% df_nodes$Agglomeration_ID)
```

```{r}
# Create a graph 'g_africa' from data frames 'df_edges' and 'df_nodes'
# The graph is undirected (directed = FALSE)
G <- graph_from_data_frame(d = df_edges,
                                       vertices = df_nodes,
                                       directed = FALSE)

```

```{r}
V(G)$size <- 0.5*(V(G)$Pop2015/10000)^0.4

plot(G, vertex.size=V(G)$size, edge.arrow.size=.15, edge.arrow.width=.2, edge.curved=0.1, edge.width=1, edge.color ="gray90",
vertex.color="red", vertex.frame.color="black", vertex.frame.width=0.2,
vertex.label=" ", vertex.label.color="black",
vertex.label.cex=.65) 
```

```{r}
# Create an empty list to store lengths

components <- data.frame(nodeID = integer(0), component = integer(0), threshold = integer(0), gcc = integer(0))

thresholds <- list()
gccs <- list()
ncs <- list()

```

```{r}

# Iterate over thresholds
for (i in seq(0, max(df_edges$l))) {
  # Create a copy of the graph G
  G_ <- G 
  
  # Find indices of edges with lengths greater than the current threshold (i)
  edges_to_remove <- which(E(G_)$l > i)
  
  # Delete edges from G_ based on their indices
  G_ <- delete_edges(G_, edges_to_remove)
  
  # Get connected components of the modified graph G_
  connected_components <- components(G_)
  
  # Create a data frame 'df_threshold' containing node IDs, component indices,
  # threshold values, and sizes of connected components
  df_threshold <- data.frame(nodeID = df_nodes$Agglomeration_ID, component = connected_components$membership, threshold = rep(i, times= nrow(df_nodes)), gcc = rep(max(connected_components$csize), times= nrow(df_nodes)))
  
  # Append 'df_threshold' to the 'components' data frame
  components <- rbind(components, df_threshold)
  
  thresholds <- append(thresholds, i)
  gccs <- append(gccs, max(connected_components$csize))
  ncs <- append(ncs, connected_components$no)
}


head(components)
```

```{r}
plot(thresholds, gccs)
```
```{r}
plot(thresholds, ncs)
```



```{r}
components_100 <- subset(components, components$threshold == 100)
```

```{r}
vertex_attr(G, "components_100") <- components_100$component
```

```{r}
plot(G, vertex.size=V(G)$size, edge.arrow.size=.15, edge.arrow.width=.2, edge.curved=0.1, edge.width=1, edge.color ="gray90",
vertex.color=V(G)$components_100, vertex.frame.color="black", vertex.frame.width=0.2,
vertex.label=" ", vertex.label.color="black",
vertex.label.cex=.65) 
```

## Measuring network robustness
